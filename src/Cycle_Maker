import maya.cmds as cmds
import re

class CycleMakerUI:
    def __init__(self):
        self.window = "cycleMakerWin"
        self.left_controls = []
        self.right_controls = []
        self.prefix_field = None
        self.left_list_field = None
        self.right_list_field = None
        self.time_offset_field = None
        self.float_offset_field = None
        # Spine/centerline inversion UI handles and defaults
        self.spine_keywords_field = None
        self.invert_y_chk = None
        self.invert_z_chk = None
        self.spine_keywords_default = [
            'spine', 'chest', 'torso', 'back', 'hip', 'pelvis', 'waist', 'abdomen',
            'cog', 'root', 'body', 'head', 'tail'
        ]
        self.spine_invert_y_default = True
        self.spine_invert_z_default = True
        self.setup_ui()

    def setup_ui(self):
        if cmds.window(self.window, exists=True):
            cmds.deleteUI(self.window)
        self.window = cmds.window(self.window, title="Cycle Maker Tool", widthHeight=(500, 400))
        cmds.columnLayout(adjustableColumn=True)
        cmds.text(label="Rig Prefix:")
        self.prefix_field = cmds.textField(text="tigerA_rigMain_01_:")
        cmds.separator(height=10)
        cmds.text(label="Controls (Select one side, auto-fills other side):")
        cmds.rowLayout(numberOfColumns=2, adjustableColumn=1)
        self.left_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        self.right_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        cmds.setParent('..')
        cmds.rowLayout(numberOfColumns=2)
        cmds.button(label="Add Selected", command=self.add_selected_controls)
        cmds.button(label="Remove Selected", command=self.remove_selected_controls)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Offsets with labels
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(120, 100, 120, 100), adjustableColumn=2)
        cmds.text(label="Time Offset (frames):")
        self.time_offset_field = cmds.intField(value=20)
        cmds.text(label="Float Offset (units):")
        self.float_offset_field = cmds.intField(value=0)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Copy direction buttons in a row
        cmds.rowLayout(numberOfColumns=3, columnWidth3=(160, 160, 160), adjustableColumn=2)
        cmds.button(label="Copy Left → Right", command=self.copy_left_to_right)
        cmds.button(label="Copy Both Ways", command=self.mirror_keys)
        cmds.button(label="Copy Right → Left", command=self.copy_right_to_left)
        cmds.setParent('..')
        # Infinity options
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(200, 240), adjustableColumn=2)
        cmds.text(label="Force Cycle Infinity (pri/poi):")
        self.force_cycle_chk = cmds.checkBox(label='', value=False)
        cmds.setParent('..')

        # Spine/centerline inversion options
        cmds.frameLayout(label="Spine/Centerline Inversion", collapsable=True, collapse=False, marginHeight=6, marginWidth=6)
        cmds.columnLayout(adjustableColumn=True, rowSpacing=4)
        cmds.text(label="Controls matching these keywords (comma-separated) will invert rotateY/rotateZ:")
        self.spine_keywords_field = cmds.textField(text=",".join(self.spine_keywords_default))
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(140, 60, 140, 60), adjustableColumn=2)
        cmds.text(label="Invert rotateY:")
        self.invert_y_chk = cmds.checkBox(label='', value=self.spine_invert_y_default)
        cmds.text(label="Invert rotateZ:")
        self.invert_z_chk = cmds.checkBox(label='', value=self.spine_invert_z_default)
        cmds.setParent('..')  # rowLayout
        # Action button for manual spine inversion
        cmds.separator(height=6)
        cmds.button(label="Invert Spine Channels on Selection", command=self.invert_spine_channels)
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout

        cmds.separator(height=10)
        cmds.button(label="Load Default Biped Controls", command=self.load_biped_defaults)
        cmds.button(label="Load Default Quadruped Controls", command=self.load_quad_defaults)
        cmds.showWindow(self.window)

    def add_selected_controls(self, *_):
        sel = cmds.ls(selection=True)
        for ctrl in sel:
            ctrl_short = ctrl.split(':')[-1] if ':' in ctrl else ctrl
            if self.is_left(ctrl_short):
                right_ctrl = self.get_other_side(ctrl_short, left_to_right=True)
                # Maintain paired alignment
                if ctrl_short not in self.left_controls and right_ctrl and right_ctrl not in self.right_controls:
                    self.left_controls.append(ctrl_short)
                    self.right_controls.append(right_ctrl)
                    cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
                else:
                    # If lists already contain one side, try to align by index
                    if ctrl_short not in self.left_controls:
                        self.left_controls.append(ctrl_short)
                        cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    if right_ctrl and right_ctrl not in self.right_controls:
                        self.right_controls.append(right_ctrl)
                        cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
            elif self.is_right(ctrl_short):
                left_ctrl = self.get_other_side(ctrl_short, left_to_right=False)
                if ctrl_short not in self.right_controls and left_ctrl and left_ctrl not in self.left_controls:
                    self.right_controls.append(ctrl_short)
                    self.left_controls.append(left_ctrl)
                    cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
                else:
                    if ctrl_short not in self.right_controls:
                        self.right_controls.append(ctrl_short)
                        cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    if left_ctrl and left_ctrl not in self.left_controls:
                        self.left_controls.append(left_ctrl)
                        cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
            else:
                cmds.warning(f"Control name does not match left/right pattern: {ctrl_short}")

    def remove_selected_controls(self, *_):
        left_selected = cmds.textScrollList(self.left_list_field, query=True, selectItem=True) or []
        right_selected = cmds.textScrollList(self.right_list_field, query=True, selectItem=True) or []
        for ctrl in left_selected:
            cmds.textScrollList(self.left_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.left_controls:
                self.left_controls.remove(ctrl)
            right_ctrl = self.get_other_side(ctrl, left_to_right=True)
            if right_ctrl:
                cmds.textScrollList(self.right_list_field, edit=True, removeItem=right_ctrl)
                if right_ctrl in self.right_controls:
                    self.right_controls.remove(right_ctrl)
        for ctrl in right_selected:
            cmds.textScrollList(self.right_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.right_controls:
                self.right_controls.remove(ctrl)
            left_ctrl = self.get_other_side(ctrl, left_to_right=False)
            if left_ctrl:
                cmds.textScrollList(self.left_list_field, edit=True, removeItem=left_ctrl)
                if left_ctrl in self.left_controls:
                    self.left_controls.remove(left_ctrl)

    # ---------------------
    # Animation helpers
    # ---------------------
    def _anim_curve_for_attr(self, attr_plug):
        """Return the first animCurve node connected to the given attribute plug.
        attr_plug is like 'node.attr'. Returns None if not found.
        """
        # Prefer robust query that traverses through utility nodes
        try:
            curves = cmds.keyframe(attr_plug, query=True, name=True) or []
            if curves:
                return curves[0]
        except Exception:
            pass

        # Fallback: direct connections
        conns = cmds.listConnections(attr_plug, s=True, d=False) or []
        for n in conns:
            try:
                nt = cmds.nodeType(n)
            except Exception:
                continue
            if isinstance(nt, str) and nt.startswith('animCurve'):
                return n
        return None

    def _apply_infinity_from_source(self, source_curve, target_curve):
        """Copy pre/post infinity from source_curve to target_curve.
        Set pri and poi in separate calls and verify; fallback to setting enum ints if needed.
        """
        if not source_curve or not target_curve:
            return
        try:
            pre_val = cmds.getAttr('{}.preInfinity'.format(source_curve))
            post_val = cmds.getAttr('{}.postInfinity'.format(source_curve))
        except Exception:
            return
        inf_map = {0: 'constant', 1: 'linear', 2: 'cycle', 3: 'cycleRelative', 4: 'oscillate'}
        pre_str = inf_map.get(pre_val, 'constant')
        post_str = inf_map.get(post_val, 'constant')

        # Apply pre infinity
        ok_pre = False
        try:
            cmds.setInfinity(target_curve, pri=pre_str)
            ok_pre = (cmds.getAttr('{}.preInfinity'.format(target_curve)) == pre_val)
        except Exception:
            ok_pre = False
        if not ok_pre:
            try:
                cmds.setAttr('{}.preInfinity'.format(target_curve), pre_val)
            except Exception:
                pass

        # Apply post infinity
        ok_post = False
        try:
            cmds.setInfinity(target_curve, poi=post_str)
            ok_post = (cmds.getAttr('{}.postInfinity'.format(target_curve)) == post_val)
        except Exception:
            ok_post = False
        if not ok_post:
            try:
                cmds.setAttr('{}.postInfinity'.format(target_curve), post_val)
            except Exception:
                pass

    def _keyed_attributes(self, node):
        """Return a list of attribute names on node that have connected animCurves."""
        attrs = []
        try:
            curves = cmds.keyframe(node, query=True, name=True) or []
        except Exception:
            curves = []
        if not curves:
            return attrs
        for c in set(curves):
            try:
                dest_plugs = cmds.listConnections(c + '.output', s=False, d=True, p=True) or []
            except Exception:
                dest_plugs = []
            for plug in dest_plugs:
                if plug.startswith(node + '.'):
                    attrs.append(plug.split('.')[-1])
        return list(dict.fromkeys(attrs))  # unique, preserve order

    # ---------------------
    # Spine inversion helpers
    # ---------------------
    def _spine_keywords(self):
        """Return lowercase list of configured spine keywords from UI."""
        try:
            raw = cmds.textField(self.spine_keywords_field, query=True, text=True) or ""
        except Exception:
            raw = ",".join(self.spine_keywords_default)
        parts = re.split(r"[,\s]+", raw.strip().lower())
        return [p for p in parts if p]

    def _should_invert_for_spine(self, node_name, attr):
        """True if node matches spine keywords and attr is selected for inversion (rotateY/rotateZ)."""
        short = node_name.split(':')[-1].lower()
        if not any(k in short for k in self._spine_keywords()):
            return False
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default
        if attr == 'rotateY' and invert_y:
            return True
        if attr == 'rotateZ' and invert_z:
            return True
        return False

    def _playback_cycle_range(self):
        """Return (start, end, mid) from playback options, fallback to (0,40,20)."""
        try:
            start = float(cmds.playbackOptions(query=True, min=True))
            end = float(cmds.playbackOptions(query=True, max=True))
        except Exception:
            start, end = 0.0, 40.0
        if end <= start:
            end = start + 40.0
        mid = (start + end) / 2.0
        return start, end, mid

    def _has_key_at(self, plug, t):
        """Return True if there's a key on plug at time t."""
        try:
            times = cmds.keyframe(plug, query=True, time=(t, t), timeChange=True) or []
            return any(abs(tt - t) < 1e-4 for tt in times)
        except Exception:
            return False

    def _ensure_key(self, plug, t, value=None):
        """Ensure a key exists at time t with a given value (or current eval if None)."""
        try:
            if value is None:
                value = cmds.getAttr(plug, time=t)
            cmds.setKeyframe(plug, time=t, value=value)
        except Exception:
            pass

    def _rebuild_second_half_antiphase(self, plug, start, mid, end):
        """Make [mid,end] equal to the negative of [start,mid] for the given plug."""
        # Anchor values
        try:
            v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = None
        if not self._has_key_at(plug, start):
            self._ensure_key(plug, start, v_start)
        if not self._has_key_at(plug, mid):
            # Create a temp key at mid to aid paste alignment
            self._ensure_key(plug, mid, v_start if v_start is not None else None)

        # Unlock if needed
        relock = False
        try:
            if cmds.getAttr(plug, lock=True):
                relock = True
                cmds.setAttr(plug, lock=False)
        except Exception:
            pass

        # Clear second half
        try:
            cmds.cutKey(plug, time=(mid, end))
        except Exception:
            pass

        # Copy first half [start, mid) and paste to [mid, end)
        try:
            cmds.copyKey(plug, time=(start, mid), includeUpperBound=False)
        except Exception as e:
            cmds.warning(f"copyKey failed on {plug} [{start},{mid}): {e}")
            return
        try:
            # Merge to avoid wiping existing keys in the first half
            cmds.pasteKey(plug, option='merge', timeOffset=(mid - start))
        except Exception as e:
            # Fallback minimal paste
            try:
                cmds.pasteKey(plug, option='merge')
            except Exception as e2:
                cmds.warning(f"pasteKey failed on {plug}: {e2}")
                return

        # Negate pasted second half
        try:
            cmds.scaleKey(plug, time=(mid, end), valueScale=-1.0)
        except Exception as e:
            cmds.warning(f"scaleKey invert failed on {plug}: {e}")

        # Enforce anchors: end==start, mid==-start
        try:
            if v_start is None:
                v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = 0.0
        self._ensure_key(plug, mid, -float(v_start))
        self._ensure_key(plug, end, float(v_start))

        # Relock
        if relock:
            try:
                cmds.setAttr(plug, lock=True)
            except Exception:
                pass

    def get_key_options(self):
        """Get common key options for copy/paste operations."""
        time_offset = cmds.intField(self.time_offset_field, query=True, value=True)
        value_offset = cmds.intField(self.float_offset_field, query=True, value=True)
        return {
            "option": "replaceCompletely",
            "copies": 1,
            "timeOffset": time_offset,
            "valueOffset": value_offset,
            # Only include flags supported by pasteKey
        }

    def copy_keys(self, source_ctrl, target_ctrl):
        """Copy keys from source to target control."""
        prefix = cmds.textField(self.prefix_field, query=True, text=True)
        source_full = f"{prefix}{source_ctrl}" if not source_ctrl.startswith(prefix) else source_ctrl
        target_full = f"{prefix}{target_ctrl}" if not target_ctrl.startswith(prefix) else target_ctrl

        # Safety: don't allow copying onto the same control
        if source_full == target_full:
            cmds.warning(f"Source and target resolve to the same node '{source_full}'. Skipping.")
            return
        
        if cmds.objExists(source_full) and cmds.objExists(target_full):
            # Determine which source attributes actually have animation
            source_keyed_attrs = self._keyed_attributes(source_full)
            copied_any = False
            if source_keyed_attrs:
                for attr in source_keyed_attrs:
                    source_attr = f"{source_full}.{attr}"
                    target_attr = f"{target_full}.{attr}"
                    # Skip if target doesn't have this attribute
                    try:
                        if not cmds.attributeQuery(attr, node=target_full, exists=True):
                            continue
                    except Exception:
                        continue
                    
                    # Check if source attribute has animation
                    source_curve = self._anim_curve_for_attr(source_attr)
                    if source_curve:
                        time_range = cmds.keyframe(source_curve, query=True, timeChange=True)
                        # Ensure ordered [start, end]
                        if time_range:
                            start_t = min(time_range)
                            end_t = max(time_range)
                            # Copy keyframes
                            try:
                                cmds.copyKey(source_attr, time=(start_t, end_t), includeUpperBound=True)
                            except Exception as e:
                                cmds.warning(f"copyKey failed on {source_attr}: {e}")
                                continue

                            # Temporarily unlock target attribute if locked
                            relock = False
                            try:
                                if cmds.getAttr(target_attr, lock=True):
                                    relock = True
                                    cmds.setAttr(target_attr, lock=False)
                            except Exception:
                                pass

                            paste_opts = self.get_key_options()
                            try:
                                cmds.pasteKey(target_attr, **paste_opts)
                            except Exception as e:
                                cmds.warning(f"pasteKey failed on {target_attr}: {e}")
                                # Try minimal flags as fallback
                                try:
                                    cmds.pasteKey(target_attr, option='replaceCompletely')
                                except Exception as e2:
                                    cmds.warning(f"pasteKey fallback failed on {target_attr}: {e2}")
                                    if relock:
                                        try:
                                            cmds.setAttr(target_attr, lock=True)
                                        except Exception:
                                            pass
                                    continue

                            # Note: spine inversion is now a separate manual process via UI button

                            # Restore lock if needed
                            if relock:
                                try:
                                    cmds.setAttr(target_attr, lock=True)
                                except Exception:
                                    pass
                            copied_any = True
                            
                            # Copy infinity settings directly curve-to-curve
                            # Find all animCurves influencing this attribute (through any intermediates)
                            try:
                                target_curves = cmds.keyframe(target_attr, query=True, name=True) or []
                            except Exception:
                                target_curves = []
                            # Unique list
                            target_curves = list(dict.fromkeys(target_curves))
                            for target_curve in target_curves:
                                try:
                                    if cmds.checkBox(self.force_cycle_chk, query=True, value=True):
                                        # Set pri and poi separately and verify
                                        try:
                                            cmds.setInfinity(target_curve, pri='cycle')
                                        except Exception:
                                            pass
                                        try:
                                            cmds.setInfinity(target_curve, poi='cycle')
                                        except Exception:
                                            pass
                                        # As a last resort, set enum values directly
                                        try:
                                            cmds.setAttr(target_curve + '.preInfinity', 2)
                                            cmds.setAttr(target_curve + '.postInfinity', 2)
                                        except Exception:
                                            pass
                                    else:
                                        self._apply_infinity_from_source(source_curve, target_curve)
                                except Exception:
                                    # Final fallback to cycle on both ends via enum
                                    try:
                                        cmds.setAttr(target_curve + '.preInfinity', 2)
                                        cmds.setAttr(target_curve + '.postInfinity', 2)
                                    except Exception:
                                        pass
            if not copied_any:
                if not source_keyed_attrs:
                    cmds.warning(f"No keyed attributes found on source {source_full}.")
                else:
                    cmds.warning(f"No matching attributes on target {target_full} for source keyed attributes: {source_keyed_attrs}")
        else:
            cmds.warning(f"Control not found: {source_full} or {target_full}")

    def copy_left_to_right(self, *_):
        """Copy animation from left controls to right controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            left_ctrl = self.left_controls[i]
            # Prefer the explicit paired right control; fallback to name swap if missing/empty
            right_ctrl = self.right_controls[i] if i < len(self.right_controls) and self.right_controls[i] else self.get_other_side(left_ctrl, left_to_right=True)
            if left_ctrl == right_ctrl:
                cmds.warning(f"Skipping pair with identical names: {left_ctrl}")
                continue
            self.copy_keys(left_ctrl, right_ctrl)

    def copy_right_to_left(self, *_):
        """Copy animation from right controls to left controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            right_ctrl = self.right_controls[i]
            # Prefer the explicit paired left control; fallback to name swap if missing/empty
            left_ctrl = self.left_controls[i] if i < len(self.left_controls) and self.left_controls[i] else self.get_other_side(right_ctrl, left_to_right=False)
            if right_ctrl == left_ctrl:
                cmds.warning(f"Skipping pair with identical names: {right_ctrl}")
                continue
            self.copy_keys(right_ctrl, left_ctrl)

    def mirror_keys(self, *_):
        """Copy keys in both directions."""
        # Store original values
        orig_time_offset = cmds.intField(self.time_offset_field, query=True, value=True)
        orig_float_offset = cmds.intField(self.float_offset_field, query=True, value=True)
        
        # Copy left to right with positive offset
        cmds.intField(self.time_offset_field, edit=True, value=abs(orig_time_offset))
        cmds.intField(self.float_offset_field, edit=True, value=abs(orig_float_offset))
        self.copy_left_to_right()
        
        # Copy right to left with negative offset
        cmds.intField(self.time_offset_field, edit=True, value=-abs(orig_time_offset))
        cmds.intField(self.float_offset_field, edit=True, value=-abs(orig_float_offset))
        self.copy_right_to_left()
        
        # Restore original values
        cmds.intField(self.time_offset_field, edit=True, value=orig_time_offset)
        cmds.intField(self.float_offset_field, edit=True, value=orig_float_offset)

    def is_left(self, name):
        # Accepts left controls with any prefix, e.g. ...:L_...
        return bool(re.search(r"(^|:|_)L_", name))

    def is_right(self, name):
        # Accepts right controls with any prefix, e.g. ...:R_...
        return bool(re.search(r"(^|:|_)R_", name))

    def get_other_side(self, name, left_to_right=True):
        if left_to_right:
            return re.sub(r"(^|:|_)L_", r"\1R_", name)
        else:
            return re.sub(r"(^|:|_)R_", r"\1L_", name)

    def load_biped_defaults(self, *_):
        lefts = ["L_leg_CTL", "L_arm_CTL", "L_foot_CTL", "L_hand_CTL", "L_clavicle_CTL"]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    def load_quad_defaults(self, *_):
        lefts = [
            "L_ikFrontLegHandle_CTL", "L_frontClavicle_CTL", "L_frontFootToe_CTL", "L_frontFootReverseRollBall_CTL",
            "L_frontFootIndex01_CTL", "L_frontFootIndex02_CTL", "L_frontFootMiddle01_CTL", "L_frontFootMiddle02_CTL",
            "L_frontFootRing01_CTL", "L_frontFootRing02_CTL", "L_frontFootPinky01_CTL", "L_frontFootPinky02_CTL"
        ]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    # ---------------------
    # Actions: Spine inversion pass
    # ---------------------
    def invert_spine_channels(self, *_):
        """Enforce half-cycle antiphase on rotateY/rotateZ over the playback range.
        For [start,end] with mid=(start+end)/2: values in [mid,end] are the negative of [start,mid].
        """
        sel = cmds.ls(selection=True) or []
        if not sel:
            cmds.warning("Select one or more controls to invert spine channels.")
            return
        keywords = self._spine_keywords()
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default

        start, end, mid = self._playback_cycle_range()
        if end <= start:
            cmds.warning("Invalid playback range. Set a valid range (e.g., 0 to 40).")
            return

        count = 0
        for node in sel:
            short = node.split(':')[-1].lower()
            if not any(k in short for k in keywords):
                continue
            for attr in (('rotateY' if invert_y else None), ('rotateZ' if invert_z else None)):
                if not attr:
                    continue
                plug = f"{node}.{attr}"
                try:
                    if not cmds.objExists(plug):
                        continue
                except Exception:
                    continue
                # Require at least one animCurve for the attr
                if not self._anim_curve_for_attr(plug):
                    continue
                # Rebuild second half as negative of first half
                self._rebuild_second_half_antiphase(plug, start, mid, end)
                count += 1

        if count == 0:
            cmds.warning("No matching spine channels processed. Check selection, keywords, and playback range.")
        else:
            cmds.inViewMessage(amg=f"Applied antiphase to {count} channel(s) over [{start:.0f},{end:.0f}]", pos='midCenter', fade=True)


def launch_cycle_maker():
    CycleMakerUI()

if __name__ == "__main__":
    launch_cycle_maker()