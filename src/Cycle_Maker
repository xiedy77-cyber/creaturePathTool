import maya.cmds as cmds
import re

class CycleMakerUI:
    def __init__(self):
        self.window = "cycleMakerWin"
        self.left_controls = []
        self.right_controls = []
        self.prefix_field = None
        self.left_list_field = None
        self.right_list_field = None
        self.time_offset_field = None
        self.float_offset_field = None
        # Spine/centerline inversion UI handles and defaults
        self.spine_keywords_field = None
        self.invert_y_chk = None
        self.invert_z_chk = None
        self.spine_keywords_default = [
            'spine', 'chest', 'torso', 'back', 'hip', 'pelvis', 'waist', 'abdomen',
            'cog', 'root', 'body', 'head', 'tail'
        ]
        self.spine_invert_y_default = True
        self.spine_invert_z_default = True
        self.setup_ui()

    def setup_ui(self):
        if cmds.window(self.window, exists=True):
            cmds.deleteUI(self.window)
        self.window = cmds.window(self.window, title="Cycle Maker Tool", widthHeight=(500, 400))
        cmds.columnLayout(adjustableColumn=True)
        cmds.text(label="Rig Prefix (auto-detected):")
        self.prefix_field = cmds.textField(text="tigerA_rigMain_01_:", editable=False, 
                                           backgroundColor=(0.8, 0.8, 0.8))
        cmds.separator(height=10)
        cmds.text(label="Controls (Select one side, auto-fills other side):")
        cmds.rowLayout(numberOfColumns=2, adjustableColumn=1)
        self.left_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        self.right_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        cmds.setParent('..')
        cmds.rowLayout(numberOfColumns=2)
        cmds.button(label="Add Selected", command=self.add_selected_controls)
        cmds.button(label="Remove Selected", command=self.remove_selected_controls)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Offsets with labels
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(120, 100, 120, 100), adjustableColumn=2)
        cmds.text(label="Time Offset (frames):")
        self.time_offset_field = cmds.intField(value=20)
        cmds.text(label="Float Offset (units):")
        self.float_offset_field = cmds.intField(value=0)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Copy direction buttons in a row
        cmds.rowLayout(numberOfColumns=3, columnWidth3=(160, 160, 160), adjustableColumn=2)
        cmds.button(label="Copy Left → Right", command=self.copy_left_to_right)
        cmds.button(label="Copy Both Ways", command=self.mirror_keys)
        cmds.button(label="Copy Right → Left", command=self.copy_right_to_left)
        cmds.setParent('..')
        # Manual infinity application button
        cmds.rowLayout(numberOfColumns=1, adjustableColumn=1)
        cmds.button(label="Apply Cycle Infinity To Selection", command=self.apply_cycle_infinity_for_selection)
        cmds.setParent('..')
        # Infinity options
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(200, 240), adjustableColumn=2)
        cmds.text(label="Force Cycle Infinity (pri/poi):")
        self.force_cycle_chk = cmds.checkBox(label='', value=True)  # Default to True for cycle infinity
        cmds.setParent('..')

        # Add Ensure 2+ Keys checkbox
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(200, 240), adjustableColumn=2)
        cmds.text(label="Ensure 2+ keys for cycling:")
        self.ensure_two_keys_chk = cmds.checkBox(label='', value=True)  # Default to True for ensuring 2+ keys
        cmds.setParent('..')
        
        # Spine/centerline inversion options
        cmds.frameLayout(label="Spine/Centerline Inversion", collapsable=True, collapse=False, marginHeight=6, marginWidth=6)
        cmds.columnLayout(adjustableColumn=True, rowSpacing=4)
        cmds.text(label="Controls matching these keywords (comma-separated) will invert rotateY/rotateZ:")
        self.spine_keywords_field = cmds.textField(text=",".join(self.spine_keywords_default))
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(140, 60, 140, 60), adjustableColumn=2)
        cmds.text(label="Invert rotateY:")
        self.invert_y_chk = cmds.checkBox(label='', value=self.spine_invert_y_default)
        cmds.text(label="Invert rotateZ:")
        self.invert_z_chk = cmds.checkBox(label='', value=self.spine_invert_z_default)
        cmds.setParent('..')  # rowLayout
        # Action button for manual spine inversion
        cmds.separator(height=6)
        cmds.button(label="Invert Spine Channels on Selection", command=self.invert_spine_channels)
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout

        cmds.separator(height=10)
        cmds.button(label="Load Default Biped Controls", command=self.load_biped_defaults)
        cmds.button(label="Load Default Quadruped Controls", command=self.load_quad_defaults)
        cmds.showWindow(self.window)

    def add_selected_controls(self, *_):
        sel = cmds.ls(selection=True)
        if not sel:
            cmds.warning("No controls selected.")
            return
            
        # Auto-detect and update rig prefix from first selected control
        first_ctrl = sel[0]
        detected_prefix = self.extract_rig_prefix(first_ctrl)
        current_prefix = cmds.textField(self.prefix_field, query=True, text=True)
        
        # Update prefix if it's different from current or if current is default
        if detected_prefix != current_prefix or current_prefix == "tigerA_rigMain_01_:":
            cmds.textField(self.prefix_field, edit=True, text=detected_prefix)
            if detected_prefix:
                cmds.inViewMessage(amg=f"Rig prefix auto-detected: {detected_prefix}", pos='midCenter', fade=True)
            else:
                cmds.inViewMessage(amg="No namespace detected in selection", pos='midCenter', fade=True)
        
        for ctrl in sel:
            ctrl_short = ctrl.split(':')[-1] if ':' in ctrl else ctrl
            if self.is_left(ctrl_short):
                right_ctrl = self.get_other_side(ctrl_short, left_to_right=True)
                # Maintain paired alignment
                if ctrl_short not in self.left_controls and right_ctrl and right_ctrl not in self.right_controls:
                    self.left_controls.append(ctrl_short)
                    self.right_controls.append(right_ctrl)
                    cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
                else:
                    # If lists already contain one side, try to align by index
                    if ctrl_short not in self.left_controls:
                        self.left_controls.append(ctrl_short)
                        cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    if right_ctrl and right_ctrl not in self.right_controls:
                        self.right_controls.append(right_ctrl)
                        cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
            elif self.is_right(ctrl_short):
                left_ctrl = self.get_other_side(ctrl_short, left_to_right=False)
                if ctrl_short not in self.right_controls and left_ctrl and left_ctrl not in self.left_controls:
                    self.right_controls.append(ctrl_short)
                    self.left_controls.append(left_ctrl)
                    cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
                else:
                    if ctrl_short not in self.right_controls:
                        self.right_controls.append(ctrl_short)
                        cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    if left_ctrl and left_ctrl not in self.left_controls:
                        self.left_controls.append(left_ctrl)
                        cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
            else:
                cmds.warning(f"Control name does not match left/right pattern: {ctrl_short}")

    def remove_selected_controls(self, *_):
        left_selected = cmds.textScrollList(self.left_list_field, query=True, selectItem=True) or []
        right_selected = cmds.textScrollList(self.right_list_field, query=True, selectItem=True) or []
        for ctrl in left_selected:
            cmds.textScrollList(self.left_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.left_controls:
                self.left_controls.remove(ctrl)
            right_ctrl = self.get_other_side(ctrl, left_to_right=True)
            if right_ctrl:
                cmds.textScrollList(self.right_list_field, edit=True, removeItem=right_ctrl)
                if right_ctrl in self.right_controls:
                    self.right_controls.remove(right_ctrl)
        for ctrl in right_selected:
            cmds.textScrollList(self.right_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.right_controls:
                self.right_controls.remove(ctrl)
            left_ctrl = self.get_other_side(ctrl, left_to_right=False)
            if left_ctrl:
                cmds.textScrollList(self.left_list_field, edit=True, removeItem=left_ctrl)
                if left_ctrl in self.left_controls:
                    self.left_controls.remove(left_ctrl)

    # ---------------------
    # Animation helpers
    # ---------------------
    def _anim_curve_for_attr(self, attr_plug):
        """Return the first animCurve node connected to the given attribute plug.
        attr_plug is like 'node.attr'. Returns None if not found.
        """
        # Prefer robust query that traverses through utility nodes
        try:
            curves = cmds.keyframe(attr_plug, query=True, name=True) or []
            if curves:
                return curves[0]
        except Exception:
            pass

        # Fallback: direct connections
        conns = cmds.listConnections(attr_plug, s=True, d=False) or []
        for n in conns:
            try:
                nt = cmds.nodeType(n)
            except Exception:
                continue
            if isinstance(nt, str) and nt.startswith('animCurve'):
                return n
        return None

    def _apply_cycle_infinity_mel(self, curves):
        """Apply cycle infinity to animation curves using MEL commands.
        This is more reliable than the Python cmds.setInfinity approach.
        """
        if not curves:
            return

        # Normalize to list
        if isinstance(curves, str):
            curves = [curves]

        for curve in curves:
            if not curve or not cmds.objExists(curve):
                continue
            # Some animCurve types use preInfinity/postInfinity enum (int). 2 == cycle
            for attr_name, label in (("preInfinity", "pre"), ("postInfinity", "post")):
                try:
                    locked = cmds.getAttr(f"{curve}.{attr_name}", lock=True)
                except Exception:
                    locked = False
                if locked:
                    try:
                        cmds.setAttr(f"{curve}.{attr_name}", lock=False)
                    except Exception as e:
                        continue
                try:
                    before = cmds.getAttr(f"{curve}.{attr_name}")
                except Exception:
                    before = "?"
                # Direct setAttr (0=constant,1=linear,2=cycle,3=cycleRelative,4=oscillate)
                try:
                    cmds.setAttr(f"{curve}.{attr_name}", 3)
                except Exception as e:
                    # Fallback: attempt MEL targeted at curve
                    try:
                        import maya.mel as mel
                        mel.eval(f"select -r {curve};")
                        if label == 'pre':
                            mel.eval("setInfinity -pri cycle;")
                        else:
                            mel.eval("setInfinity -poi cycle;")
                    except Exception as me:
                        pass
                try:
                    after = cmds.getAttr(f"{curve}.{attr_name}")
                except Exception:
                    after = "?"
                # Relock if it was locked originally
                if locked:
                    try:
                        cmds.setAttr(f"{curve}.{attr_name}", lock=True)
                    except Exception:
                        pass

    # ---------------------
    # Advanced infinity application with multi-layer fallback & diagnostics
    # ---------------------
    def _apply_cycle_infinity_advanced(self, curves, verbose=True):
        """Attempt to set pre/post infinity to cycle with multiple strategies and diagnostics.
        Strategies per curve:
          1. Direct setInfinity command with full parameter specification
          2. Direct setAttr (int 2)
          3. cmds.setInfinity(preInfinite='cycle', postInfinite='cycle')
          4. OpenMaya API plug set (setInt)
        Batch strategies (all curves):
          5. MEL batch: select all curves once, set both pri & poi simultaneously
        Diagnostics:
          - keyframe count & times
          - reference status & node lock state
          - original and final values
          - single-key warning (cycle visually meaningless with <2 keys)
        Returns (updated, failed) lists.
        """
        if not curves:
            return [], []
        # Normalize
        if isinstance(curves, str):
            curves = [curves]
        updated = []
        pending = []
        
        # Pre-pass collect info
        for c in curves:
            if not cmds.objExists(c):
                if verbose:
                    print(f"INFINITY_ADV: Curve missing {c}")
                continue
            
            # Try direct setInfinity command first with all parameters
            try:
                # This applies to all keyframe tangents on the curve
                cmds.setInfinity(c, preInfinite="cycle", postInfinite="cycle", 
                                controlPoints=True, shape=True, hierarchy="none")
                
                # Verify it worked
                pre_val = cmds.getAttr(c+'.preInfinity')
                post_val = cmds.getAttr(c+'.postInfinity')
                if pre_val == 3 and post_val == 3:
                    if verbose:
                        print(f"INFINITY_ADV: Direct setInfinity with params success {c}")
                    updated.append(c)
                    continue
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: Direct setInfinity with params failed {c}: {e}")
            
            try:
                kt = cmds.keyframe(c, query=True, timeChange=True) or []
            except Exception:
                kt = []
            kcount = len(kt)
            try:
                ref = cmds.referenceQuery(c, isNodeReferenced=True)
            except Exception:
                ref = False
            try:
                locked_node = cmds.lockNode(c, query=True, lock=True) or [False]
                locked_node = any(locked_node)
            except Exception:
                locked_node = False
            try:
                pre0 = cmds.getAttr(c+'.preInfinity')
                post0 = cmds.getAttr(c+'.postInfinity')
            except Exception:
                pre0 = post0 = '??'
            if verbose:
                rng = (min(kt), max(kt)) if kcount else (None, None)
                print(f"INFINITY_ADV: {c} type={cmds.nodeType(c)} keys={kcount} range={rng} ref={ref} lockedNode={locked_node} pre={pre0} post={post0}")
            # Try direct setAttr first
            success_direct = False
            for attr in ('preInfinity','postInfinity'):
                try:
                    cmds.setAttr(f'{c}.{attr}', 3)
                except Exception as e:
                    if verbose:
                        print(f"INFINITY_ADV: setAttr failed {c}.{attr}: {e}")
            try:
                preA = cmds.getAttr(c+'.preInfinity')
                postA = cmds.getAttr(c+'.postInfinity')
                success_direct = (preA == 3 and postA == 3)
            except Exception:
                success_direct = False
            if success_direct:
                if verbose:
                    print(f"INFINITY_ADV: Direct setAttr success {c} -> (2,2)")
                updated.append(c)
                continue
            # Try cmds.setInfinity
            try:
                cmds.setInfinity(c, preInfinite='cycle', postInfinite='cycle')
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: cmds.setInfinity failed {c}: {e}")
            try:
                preB = cmds.getAttr(c+'.preInfinity')
                postB = cmds.getAttr(c+'.postInfinity')
                if preB == 3 and postB == 3:
                    if verbose:
                        print(f"INFINITY_ADV: cmds.setInfinity success {c}")
                    updated.append(c)
                    continue
            except Exception:
                pass
            # Try OpenMaya API
            try:
                import maya.api.OpenMaya as om
                sel = om.MSelectionList(); sel.add(c)
                mobj = sel.getDependNode(0)
                fn = om.MFnDependencyNode(mobj)
                for attr in ('preInfinity','postInfinity'):
                    plug = fn.findPlug(attr, False)
                    plug.setInt(3)
                preC = cmds.getAttr(c+'.preInfinity')
                postC = cmds.getAttr(c+'.postInfinity')
                if preC == 3 and postC == 3:
                    if verbose:
                        print(f"INFINITY_ADV: OpenMaya plug success {c}")
                    updated.append(c)
                    continue
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: OpenMaya attempt failed {c}: {e}")
            # Record for batch MEL attempt
            pending.append(c)
        # Batch MEL (single selection) if any pending
        if pending:
            if verbose:
                print(f"INFINITY_ADV: Batch MEL attempt on {len(pending)} pending curves")
            try:
                import maya.mel as mel
                mel.eval('select -r ' + ' '.join(pending) + ';')
                # Single call specifying both flags sometimes behaves differently than split calls
                mel.eval('setInfinity -pri 2 -poi 2;')  # numeric flags
                # Also try named for safety
                mel.eval('setInfinity -pri "cycle" -poi "cycle";')
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: Batch MEL failure: {e}")
            # Re-check
            recheck = []
            for c in list(pending):
                try:
                    if cmds.getAttr(c+'.preInfinity') == 3 and cmds.getAttr(c+'.postInfinity') == 3:
                        updated.append(c)
                    else:
                        recheck.append(c)
                except Exception:
                    recheck.append(c)
            pending = recheck
        # Single-key warning
        for c in list(pending):
            try:
                kcount = cmds.keyframe(c, query=True, keyframeCount=True)
                if kcount < 2:
                    if verbose:
                        print(f"INFINITY_ADV: {c} has <2 keys; cycling pre/post may be suppressed by Maya.")
            except Exception:
                pass
        return updated, pending

    # ---------------------
    # Manual infinity application
    # ---------------------
    def _collect_anim_curves_from_nodes(self, nodes):
        curves = []
        for node in nodes:
            if not cmds.objExists(node):
                continue
            # Method 1: keyframe query
            try:
                kcurves = cmds.keyframe(node, query=True, name=True) or []
                for c in kcurves:
                    if c not in curves:
                        curves.append(c)
            except Exception:
                pass
            # Method 2: listConnections by animCurve
            try:
                conns = cmds.listConnections(node, source=True, destination=False) or []
                for c in conns:
                    try:
                        if cmds.objExists(c) and cmds.nodeType(c).startswith('animCurve') and c not in curves:
                            curves.append(c)
                    except Exception:
                        continue
            except Exception:
                pass
        return curves

    def apply_cycle_infinity_for_selection(self, *_):
        sel = cmds.ls(selection=True) or []
        if not sel:
            cmds.warning("Select controls or animCurves to apply cycle infinity.")
            return

        ensure_two_keys = cmds.checkBox(self.ensure_two_keys_chk, query=True, value=True)

        direct_curves = [s for s in sel if cmds.objExists(s) and cmds.nodeType(s).startswith('animCurve')]
        target_nodes = [s for s in sel if s not in direct_curves]
        curves = list(direct_curves)
        curves += self._collect_anim_curves_from_nodes(target_nodes)
        curves = list(dict.fromkeys(curves))  # unique preserve

        if ensure_two_keys:
            for curve in curves:
                self._ensure_two_keys(curve)

        if not curves:
            cmds.warning("No animCurves found on selection.")
            return

        updated, failed = self._apply_cycle_infinity_advanced(curves, verbose=False)

        # Always generate the manual script for all curves
        self.generate_manual_infinity_script(curves)

        if updated and not failed:
            cmds.inViewMessage(amg=f"Applied cycle infinity to {len(updated)} curve(s)", pos='midCenter', fade=True)
        elif updated:
            cmds.inViewMessage(amg=f"Cycle infinity partial: {len(updated)}/{len(curves)}", pos='midCenter', fade=True)

    def generate_manual_infinity_script(self, curves):
        """Generate a script to manually apply infinity settings to the given curves."""
        if not curves:
            print("No curves provided to generate a manual script.")
            return

        script_lines = []
        for curve in curves:
            if cmds.objExists(curve):
                script_lines.append(f"cmds.setAttr('{curve}.preInfinity', 3)")
                script_lines.append(f"cmds.setAttr('{curve}.postInfinity', 3)")

        if script_lines:
            print("\n# Generated script to manually apply infinity settings:\n")
            for line in script_lines:
                print(line)
            print("\n# End of script\n")
        else:
            print("No valid curves found to generate a script.")

    def _apply_infinity_from_source(self, source_curve, target_curve):
        """Copy pre/post infinity from source_curve to target_curve.
        If force_cycle is enabled, applies cycle infinity instead.
        """
        if not source_curve or not target_curve:
            return
            
        # Check if force cycle is enabled
        try:
            force_cycle = cmds.checkBox(self.force_cycle_chk, query=True, value=True)
        except Exception:
            force_cycle = False
            
        if force_cycle:
            # Force cycle using direct attr method
            self._apply_cycle_infinity_mel([target_curve])
            return
            
        try:
            pre_val = cmds.getAttr('{}.preInfinity'.format(source_curve))
            post_val = cmds.getAttr('{}.postInfinity'.format(source_curve))
        except Exception:
            return
        inf_map = {0: 'constant', 1: 'linear', 2: 'cycle', 3: 'cycleRelative', 4: 'oscillate'}
        pre_str = inf_map.get(pre_val, 'constant')
        post_str = inf_map.get(post_val, 'constant')

        try:
            # Select the curve and use MEL commands for reliability
            cmds.select(target_curve, replace=True)
            import maya.mel as mel
            mel.eval(f"setInfinity -pri {pre_str};")
            mel.eval(f"setInfinity -poi {post_str};")
            cmds.select(clear=True)
        except Exception:
            # Fallback to direct attribute setting
            try:
                cmds.setAttr('{}.preInfinity'.format(target_curve), pre_val)
                cmds.setAttr('{}.postInfinity'.format(target_curve), post_val)
            except Exception:
                pass

    def _keyed_attributes(self, node):
        """Return a list of attribute names on node that have connected animCurves."""
        attrs = []
        try:
            curves = cmds.keyframe(node, query=True, name=True) or []
        except Exception:
            curves = []
        if not curves:
            return attrs
        for c in set(curves):
            try:
                dest_plugs = cmds.listConnections(c + '.output', s=False, d=True, p=True) or []
            except Exception:
                dest_plugs = []
            for plug in dest_plugs:
                if plug.startswith(node + '.'):
                    attrs.append(plug.split('.')[-1])
        return list(dict.fromkeys(attrs))  # unique, preserve order

    # ---------------------
    # Spine inversion helpers
    # ---------------------
    def _spine_keywords(self):
        """Return lowercase list of configured spine keywords from UI."""
        try:
            raw = cmds.textField(self.spine_keywords_field, query=True, text=True) or ""
        except Exception:
            raw = ",".join(self.spine_keywords_default)
        parts = re.split(r"[,\s]+", raw.strip().lower())
        return [p for p in parts if p]

    def _should_invert_for_spine(self, node_name, attr):
        """True if node matches spine keywords and attr is selected for inversion (rotateY/rotateZ)."""
        short = node_name.split(':')[-1].lower()
        if not any(k in short for k in self._spine_keywords()):
            return False
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default
        if attr == 'rotateY' and invert_y:
            return True
        if attr == 'rotateZ' and invert_z:
            return True
        return False

    def _playback_cycle_range(self):
        """Return (start, end, mid) from playback options, fallback to (0,40,20)."""
        try:
            start = float(cmds.playbackOptions(query=True, min=True))
            end = float(cmds.playbackOptions(query=True, max=True))
        except Exception:
            start, end = 0.0, 40.0
        if end <= start:
            end = start + 40.0
        mid = (start + end) / 2.0
        return start, end, mid

    def _has_key_at(self, plug, t):
        """Return True if there's a key on plug at time t."""
        try:
            times = cmds.keyframe(plug, query=True, time=(t, t), timeChange=True) or []
            return any(abs(tt - t) < 1e-4 for tt in times)
        except Exception:
            return False

    def _ensure_key(self, plug, t, value=None):
        """Ensure a key exists at time t with a given value (or current eval if None)."""
        try:
            if value is None:
                value = cmds.getAttr(plug, time=t)
            cmds.setKeyframe(plug, time=t, value=value)
        except Exception:
            pass

    def _rebuild_second_half_antiphase(self, plug, start, mid, end):
        """Make [mid,end] equal to the negative of [start,mid] for the given plug."""
        # Anchor values
        try:
            v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = None
        if not self._has_key_at(plug, start):
            self._ensure_key(plug, start, v_start)
        if not self._has_key_at(plug, mid):
            # Create a temp key at mid to aid paste alignment
            self._ensure_key(plug, mid, v_start if v_start is not None else None)

        # Unlock if needed
        relock = False
        try:
            if cmds.getAttr(plug, lock=True):
                relock = True
                cmds.setAttr(plug, lock=False)
        except Exception:
            pass

        # Clear second half
        try:
            cmds.cutKey(plug, time=(mid, end))
        except Exception:
            pass

        # Copy first half [start, mid) and paste to [mid, end)
        try:
            cmds.copyKey(plug, time=(start, mid), includeUpperBound=False)
        except Exception as e:
            cmds.warning(f"copyKey failed on {plug} [{start},{mid}): {e}")
            return
        try:
            # Merge to avoid wiping existing keys in the first half
            cmds.pasteKey(plug, option='merge', timeOffset=(mid - start))
        except Exception as e:
            # Fallback minimal paste
            try:
                cmds.pasteKey(plug, option='merge')
            except Exception as e2:
                cmds.warning(f"pasteKey failed on {plug}: {e2}")
                return

        # Negate pasted second half
        try:
            cmds.scaleKey(plug, time=(mid, end), valueScale=-1.0)
        except Exception as e:
            cmds.warning(f"scaleKey invert failed on {plug}: {e}")

        # Enforce anchors: end==start, mid==-start
        try:
            if v_start is None:
                v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = 0.0
        self._ensure_key(plug, mid, -float(v_start))
        self._ensure_key(plug, end, float(v_start))

        # Relock
        if relock:
            try:
                cmds.setAttr(plug, lock=True)
            except Exception:
                pass

    def _ensure_two_keys(self, curve):
        """Ensure the given curve has at least two keys."""
        try:
            key_times = cmds.keyframe(curve, query=True, timeChange=True) or []
            if len(key_times) < 2:
                value = cmds.keyframe(curve, query=True, valueChange=True)[0]
                playback_start = cmds.playbackOptions(query=True, min=True)
                playback_end = cmds.playbackOptions(query=True, max=True)
                cmds.setKeyframe(curve, time=playback_start, value=value)
                cmds.setKeyframe(curve, time=playback_end, value=value)
        except Exception:
            pass

    def get_key_options(self):
        """Get common key options for copy/paste operations."""
        time_offset = cmds.intField(self.time_offset_field, query=True, value=True)
        value_offset = cmds.intField(self.float_offset_field, query=True, value=True)
        return {
            "option": "replaceCompletely",
            "copies": 1,
            "timeOffset": time_offset,
            "valueOffset": value_offset,
            # Only include flags supported by pasteKey
        }

    def copy_keys(self, source_ctrl, target_ctrl):
        """Copy keys from source to target control."""
        prefix = cmds.textField(self.prefix_field, query=True, text=True)
        source_full = f"{prefix}{source_ctrl}" if not source_ctrl.startswith(prefix) else source_ctrl
        target_full = f"{prefix}{target_ctrl}" if not target_ctrl.startswith(prefix) else target_ctrl

        # Safety: don't allow copying onto the same control
        if source_full == target_full:
            cmds.warning(f"Source and target resolve to the same node '{source_full}'. Skipping.")
            return
        
        if cmds.objExists(source_full) and cmds.objExists(target_full):
            # Determine which source attributes actually have animation
            source_keyed_attrs = self._keyed_attributes(source_full)
            copied_any = False
            if source_keyed_attrs:
                for attr in source_keyed_attrs:
                    source_attr = f"{source_full}.{attr}"
                    target_attr = f"{target_full}.{attr}"
                    # Skip if target doesn't have this attribute
                    try:
                        if not cmds.attributeQuery(attr, node=target_full, exists=True):
                            continue
                    except Exception:
                        continue
                    
                    # Check if source attribute has animation
                    source_curve = self._anim_curve_for_attr(source_attr)
                    if source_curve:
                        time_range = cmds.keyframe(source_curve, query=True, timeChange=True)
                        # Ensure ordered [start, end]
                        if time_range:
                            start_t = min(time_range)
                            end_t = max(time_range)
                            # Copy keyframes
                            try:
                                cmds.copyKey(source_attr, time=(start_t, end_t), includeUpperBound=True)
                            except Exception as e:
                                cmds.warning(f"copyKey failed on {source_attr}: {e}")
                                continue

                            # Temporarily unlock target attribute if locked
                            relock = False
                            try:
                                if cmds.getAttr(target_attr, lock=True):
                                    relock = True
                                    cmds.setAttr(target_attr, lock=False)
                            except Exception:
                                pass

                            paste_opts = self.get_key_options()
                            try:
                                cmds.pasteKey(target_attr, **paste_opts)
                            except Exception as e:
                                cmds.warning(f"pasteKey failed on {target_attr}: {e}")
                                # Try minimal flags as fallback
                                try:
                                    cmds.pasteKey(target_attr, option='replaceCompletely')
                                except Exception as e2:
                                    cmds.warning(f"pasteKey fallback failed on {target_attr}: {e2}")
                                    if relock:
                                        try:
                                            cmds.setAttr(target_attr, lock=True)
                                        except Exception:
                                            pass
                                    continue

                            # IMPORTANT: Allow Maya to process the paste operation before applying infinity
                            cmds.refresh()
                            
                            # Verify the paste worked by checking for keys
                            try:
                                key_count = cmds.keyframe(target_attr, query=True, keyframeCount=True)
                            except Exception as key_e:
                                pass
                            
                            # Note: spine inversion is now a separate manual process via UI button

                            # Restore lock if needed
                            if relock:
                                try:
                                    cmds.setAttr(target_attr, lock=True)
                                except Exception:
                                    pass
                            copied_any = True
                            
                            # Apply infinity settings using MEL commands
                            # Find all animCurves influencing this attribute AFTER paste is complete
                            target_curves = []
                            
                            # Method 1: keyframe query
                            try:
                                target_curves = cmds.keyframe(target_attr, query=True, name=True) or []
                            except Exception as e:
                                pass
                            
                            # Method 2: listConnections with animCurve type filter
                            if not target_curves:
                                try:
                                    conns = cmds.listConnections(target_attr, source=True, destination=False, type='animCurve') or []
                                    target_curves = [c for c in conns if c and cmds.objExists(c) and cmds.nodeType(c).startswith('animCurve')]
                                except Exception as e2:
                                    pass
                            
                            # Method 3: General listConnections and filter
                            if not target_curves:
                                try:
                                    all_conns = cmds.listConnections(target_attr, source=True, destination=False) or []
                                    for conn in all_conns:
                                        if conn and cmds.objExists(conn):
                                            try:
                                                node_type = cmds.nodeType(conn)
                                                if node_type and node_type.startswith('animCurve'):
                                                    target_curves.append(conn)
                                            except Exception:
                                                continue
                                except Exception as e3:
                                    pass
                            
                            # Apply infinity to target curves
                            if target_curves:
                                try:
                                    force_cycle = cmds.checkBox(self.force_cycle_chk, query=True, value=True)
                                except Exception:
                                    force_cycle = False
                                    
                                if force_cycle:
                                    # Force cycle infinity using MEL
                                    self._apply_cycle_infinity_mel(target_curves)
                                else:
                                    # Copy infinity from source using MEL
                                    for target_curve in target_curves:
                                        self._apply_infinity_from_source(source_curve, target_curve)
                            else:
                                print(f"DEBUG: WARNING - No curves found for {target_attr} after trying all methods!")
            if not copied_any:
                if not source_keyed_attrs:
                    cmds.warning(f"No keyed attributes found on source {source_full}.")
                else:
                    cmds.warning(f"No matching attributes on target {target_full} for source keyed attributes: {source_keyed_attrs}")
        else:
            cmds.warning(f"Control not found: {source_full} or {target_full}")

    def copy_left_to_right(self, *_):
        """Copy animation from left controls to right controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            left_ctrl = self.left_controls[i]
            # Prefer the explicit paired right control; fallback to name swap if missing/empty
            right_ctrl = self.right_controls[i] if i < len(self.right_controls) and self.right_controls[i] else self.get_other_side(left_ctrl, left_to_right=True)
            if left_ctrl == right_ctrl:
                cmds.warning(f"Skipping pair with identical names: {left_ctrl}")
                continue
            self.copy_keys(left_ctrl, right_ctrl)

    def copy_right_to_left(self, *_):
        """Copy animation from right controls to left controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            right_ctrl = self.right_controls[i]
            # Prefer the explicit paired left control; fallback to name swap if missing/empty
            left_ctrl = self.left_controls[i] if i < len(self.left_controls) and self.left_controls[i] else self.get_other_side(right_ctrl, left_to_right=False)
            if right_ctrl == left_ctrl:
                cmds.warning(f"Skipping pair with identical names: {right_ctrl}")
                continue
            self.copy_keys(right_ctrl, left_ctrl)

    def mirror_keys(self, *_):
        """Copy keys in both directions."""
        # Store original values
        orig_time_offset = cmds.intField(self.time_offset_field, query=True, value=True)
        orig_float_offset = cmds.intField(self.float_offset_field, query=True, value=True)
        
        # Copy left to right with positive offset
        cmds.intField(self.time_offset_field, edit=True, value=abs(orig_time_offset))
        cmds.intField(self.float_offset_field, edit=True, value=abs(orig_float_offset))
        self.copy_left_to_right()
        
        # Copy right to left with negative offset
        cmds.intField(self.time_offset_field, edit=True, value=-abs(orig_time_offset))
        cmds.intField(self.float_offset_field, edit=True, value=-abs(orig_float_offset))
        self.copy_right_to_left()
        
        # Restore original values
        cmds.intField(self.time_offset_field, edit=True, value=orig_time_offset)
        cmds.intField(self.float_offset_field, edit=True, value=orig_float_offset)

    def is_left(self, name):
        # Accepts left controls with any prefix, e.g. ...:L_... or ..._L
        return bool(re.search(r"(^|:|_)L(_|$)", name))

    def is_right(self, name):
        # Accepts right controls with any prefix, e.g. ...:R_... or ..._R
        return bool(re.search(r"(^|:|_)R(_|$)", name))

    def get_other_side(self, name, left_to_right=True):
        if left_to_right:
            # Handle both L_ and _L patterns
            name = re.sub(r"(^|:|_)L_", r"\1R_", name)
            name = re.sub(r"_L$", "_R", name)
            return name
        else:
            # Handle both R_ and _R patterns
            name = re.sub(r"(^|:|_)R_", r"\1L_", name)
            name = re.sub(r"_R$", "_L", name)
            return name

    def extract_rig_prefix(self, control_name):
        """Extract the rig prefix/namespace from a control name.
        Examples: 
        - 'the_tyrant_rig:IKLeg_R' -> 'the_tyrant_rig:'
        - 'tigerA_rigMain_01_:L_arm_CTL' -> 'tigerA_rigMain_01_:'
        - 'IKLeg_R' -> ''
        """
        if ':' in control_name:
            return control_name.split(':', 1)[0] + ':'
        return ''

    def load_biped_defaults(self, *_):
        lefts = ["L_leg_CTL", "L_arm_CTL", "L_foot_CTL", "L_hand_CTL", "L_clavicle_CTL"]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    def load_quad_defaults(self, *_):
        lefts = [
            "L_ikFrontLegHandle_CTL", "L_frontClavicle_CTL", "L_frontFootToe_CTL", "L_frontFootReverseRollBall_CTL",
            "L_frontFootIndex01_CTL", "L_frontFootIndex02_CTL", "L_frontFootMiddle01_CTL", "L_frontFootMiddle02_CTL",
            "L_frontFootRing01_CTL", "L_frontFootRing02_CTL", "L_frontFootPinky01_CTL", "L_frontFootPinky02_CTL"
        ]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    # ---------------------
    # Actions: Spine inversion pass
    # ---------------------

    def invert_spine_channels(self, *_):
        """
        Enforce half-cycle antiphase or standard cycle on spine/centerline channels over the playback range.
        - rotateY, rotateZ, translateX, translateZ: antiphase (second half = negative of first half)
        - rotateX, translateY: standard cycle (second half = copy of first half)
        """
        sel = cmds.ls(selection=True) or []
        if not sel:
            cmds.warning("Select one or more controls to invert spine channels.")
            return
        keywords = self._spine_keywords()
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default

        start, end, mid = self._playback_cycle_range()
        if end <= start:
            cmds.warning("Invalid playback range. Set a valid range (e.g., 0 to 40).")
            return

        # Define which channels get which type of cycling
        antiphase_attrs = []
        if invert_y:
            antiphase_attrs.append("rotateY")
        if invert_z:
            antiphase_attrs.append("rotateZ")
        antiphase_attrs += ["translateX"]
        standard_attrs = ["rotateX", "translateY", "translateZ"]

        count = 0
        for node in sel:
            short = node.split(":")[-1].lower()
            if not any(k in short for k in keywords):
                continue
            # Antiphase channels
            for attr in antiphase_attrs:
                plug = f"{node}.{attr}"
                try:
                    if not cmds.objExists(plug):
                        continue
                except Exception:
                    continue
                if not self._anim_curve_for_attr(plug):
                    continue
                self._rebuild_second_half_antiphase(plug, start, mid, end)
                count += 1
            # Standard cycle channels
            for attr in standard_attrs:
                plug = f"{node}.{attr}"
                try:
                    if not cmds.objExists(plug):
                        continue
                except Exception:
                    continue
                if not self._anim_curve_for_attr(plug):
                    continue
                self._rebuild_second_half_standard(plug, start, mid, end)
                count += 1

        if count == 0:
            cmds.warning("No matching spine channels processed. Check selection, keywords, and playback range.")
        else:
            cmds.inViewMessage(amg=f"Applied cycle/antiphase to {count} channel(s) over [{start:.0f},{end:.0f}]", pos='midCenter', fade=True)

    def _rebuild_second_half_standard(self, plug, start, mid, end):
        """
        Make [mid,end] a standard cycle (copy of [start,mid]) for the given plug.
        """
        # Anchor values
        try:
            v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = None
        if not self._has_key_at(plug, start):
            self._ensure_key(plug, start, v_start)
        if not self._has_key_at(plug, mid):
            self._ensure_key(plug, mid, v_start if v_start is not None else None)

        # Unlock if needed
        relock = False
        try:
            if cmds.getAttr(plug, lock=True):
                relock = True
                cmds.setAttr(plug, lock=False)
        except Exception:
            pass

        # Clear second half
        try:
            cmds.cutKey(plug, time=(mid, end))
        except Exception:
            pass

        # Copy first half [start, mid) and paste to [mid, end)
        try:
            cmds.copyKey(plug, time=(start, mid), includeUpperBound=False)
        except Exception as e:
            cmds.warning(f"copyKey failed on {plug} [{start},{mid}): {e}")
            return
        try:
            cmds.pasteKey(plug, option='merge', timeOffset=(mid - start))
        except Exception as e:
            try:
                cmds.pasteKey(plug, option='merge')
            except Exception as e2:
                cmds.warning(f"pasteKey failed on {plug}: {e2}")
                return

        # Enforce anchors: end==start, mid==start
        try:
            if v_start is None:
                v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = 0.0
        self._ensure_key(plug, mid, float(v_start))
        self._ensure_key(plug, end, float(v_start))

        # Relock
        if relock:
            try:
                cmds.setAttr(plug, lock=True)
            except Exception:
                pass


def launch_cycle_maker():
    CycleMakerUI()

if __name__ == "__main__":
    launch_cycle_maker()