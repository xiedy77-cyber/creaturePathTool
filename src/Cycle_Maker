import maya.cmds as cmds
import re

class CycleMakerUI:
    """
    Maya Animation Cycle Maker Tool
    
    A comprehensive tool for creating seamless animation cycles with automatic left/right 
    mirroring, X-axis inversion detection, spine processing, and infinity management.
    
    MAIN FEATURES:
    - Automatic rig prefix detection
    - Left/Right control pairing and mirroring  
    - Intelligent X-axis inversion detection for different rig conventions
    - Cycle infinity application with multiple fallback strategies
    - Spine/centerline inversion for rotateY/Z channels
    - Time and value offset support for layered animation
    
    FILE ORGANIZATION:
    ==================
    SECTION 1: INITIALIZATION & SETUP (lines ~30-150)
        - __init__() - Initialize variables and UI
        - setup_ui() - Create the main interface
        
    SECTION 2: CONTROL MANAGEMENT (lines ~150-250) 
        - add_selected_controls() - Add controls to left/right lists
        - remove_selected_controls() - Remove selected controls
        - load_biped_defaults() / load_quad_defaults() - Preset control lists
        
    SECTION 3: UTILITY FUNCTIONS (lines ~250-350)
        - String manipulation (is_left, is_right, get_other_side)
        - Rig prefix extraction
        - Animation curve helpers
        
    SECTION 4: X-AXIS INVERSION DETECTION (lines ~350-550)
        - detect_x_inversion_needed() - Main detection logic
        - _analyze_translate_x_patterns() - TranslateX movement analysis  
        - _analyze_rotation_patterns() - Rotation fallback analysis
        - analyze_all_control_pairs() - Batch analysis
        
    SECTION 5: INFINITY MANAGEMENT (lines ~550-750)
        - _apply_cycle_infinity_mel() - MEL-based infinity application
        - _apply_cycle_infinity_advanced() - Multi-strategy fallback system
        - apply_cycle_infinity_for_selection() - Manual infinity application
        
    SECTION 6: ANIMATION CORE FUNCTIONS (lines ~750-950)
        - copy_keys() - Main key copying with auto-inversion
        - get_key_options() - Paste options configuration
        - _keyed_attributes() - Find animated attributes
        
    SECTION 7: COPY OPERATIONS (lines ~950-1050)
        - copy_left_to_right() / copy_right_to_left() - Directional copying
        
    SECTION 8: SPINE/CENTERLINE PROCESSING (lines ~1050-1150)
        - invert_spine_channels() - Manual spine inversion
        - _should_invert_for_spine() - Spine keyword matching
        - _rebuild_second_half_antiphase() - Antiphase animation creation
        
    SECTION 9: UI CALLBACKS & HELPERS (lines ~1150-end)
        - Event handlers for buttons and checkboxes
        - Analysis result displays
        - Cache management
    """
    def __init__(self):
        self.window = "cycleMakerWin"
        self.left_controls = []
        self.right_controls = []
        self.prefix_field = None
        self.left_list_field = None
        self.right_list_field = None
        # Spine/centerline inversion UI handles and defaults
        self.spine_controls_list = None
        self.invert_y_chk = None
        self.invert_z_chk = None
        self.spine_keywords_default = [
            'spine', 'chest', 'torso', 'back', 'hip', 'pelvis', 'waist', 'abdomen',
            'cog', 'root', 'body', 'head', 'tail'
        ]
        self.spine_invert_y_default = True
        self.spine_invert_z_default = True
        # Auto-detection system for X-axis inversion
        self.auto_detect_x_inversion = True
        self.x_inversion_cache = {}  # Cache results: {(left_ctrl, right_ctrl): should_invert_bool}
        
        # Copy with Offset tab UI fields
        self.time_offset_copy_field = None
        self.value_offset_copy_field = None
        self.translate_x_chk = None
        self.translate_y_chk = None
        self.translate_z_chk = None
        self.rotate_x_chk = None
        self.rotate_y_chk = None
        self.rotate_z_chk = None
        
        self.setup_ui()

    # =========================================================================
    # SECTION 1: INITIALIZATION & UI SETUP
    # =========================================================================

    def setup_ui(self):
        if cmds.window(self.window, exists=True):
            cmds.deleteUI(self.window)
        self.window = cmds.window(self.window, title="Cycle Maker Tool", widthHeight=(520, 450))
        
        # Create main tab layout
        main_tabs = cmds.tabLayout(innerMarginWidth=5, innerMarginHeight=5)
        
        # TAB 1: Cycle Maker (original functionality)
        tab1 = cmds.columnLayout(adjustableColumn=True, parent=main_tabs)
        self.setup_cycle_maker_tab()
        
        # TAB 2: Copy with Offset
        tab2 = cmds.columnLayout(adjustableColumn=True, parent=main_tabs)
        self.setup_copy_offset_tab()
        
        # Set tab labels
        cmds.tabLayout(main_tabs, edit=True, tabLabel=((tab1, 'Cycle Maker'), (tab2, 'Copy with Offset')))
        
        cmds.showWindow(self.window)
    
    def setup_cycle_maker_tab(self):
        """Setup the original Cycle Maker functionality tab."""
        cmds.text(label="Rig Prefix (auto-detected):")
        self.prefix_field = cmds.textField(text="tigerA_rigMain_01_:", editable=False, 
                                           backgroundColor=(0.8, 0.8, 0.8))
        cmds.separator(height=10)
        cmds.text(label="Controls (Select one side, auto-fills other side):")
        
        # Single frame containing both lists with headers
        cmds.frameLayout(label="Left/Right Control Pairs", collapsable=False, marginHeight=5, marginWidth=5)
        cmds.columnLayout(adjustableColumn=True)
        # Headers
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(1, 1), adjustableColumn=1)
        cmds.text(label="Left Controls", align="center", backgroundColor=(0.3, 0.3, 0.4))
        cmds.text(label="Right Controls", align="center", backgroundColor=(0.4, 0.3, 0.3))
        cmds.setParent('..')
        # Lists
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(1, 1), adjustableColumn=1)
        self.left_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        self.right_list_field = cmds.textScrollList(allowMultiSelection=True, height=120)
        cmds.setParent('..')
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout
        
        cmds.separator(height=10)
        cmds.rowLayout(numberOfColumns=2)
        cmds.button(label="Add Selected", command=self.add_selected_controls)
        cmds.button(label="Remove Selected", command=self.remove_selected_controls)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Copy buttons - equal width
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(200, 200), adjustableColumn=1)
        cmds.button(label="Copy Left → Right", command=self.copy_left_to_right, width=200)
        cmds.button(label="Copy Right → Left", command=self.copy_right_to_left, width=200)
        cmds.setParent('..')
        cmds.separator(height=10)
        
        # Spine/centerline inversion options
        cmds.frameLayout(label="Spine/Centerline Inversion", collapsable=True, collapse=False, marginHeight=6, marginWidth=6)
        cmds.columnLayout(adjustableColumn=True, rowSpacing=4)
        cmds.text(label="Spine Controls (will invert rotateY/rotateZ):")
        
        # Spine controls list with Add/Remove buttons
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(250, 150))
        self.spine_controls_list = cmds.textScrollList(numberOfRows=4, allowMultiSelection=True, width=240)
        
        cmds.columnLayout(adjustableColumn=True, rowSpacing=2)
        cmds.button(label="Add Selected", command=self.add_selected_to_spine_list, width=140)
        cmds.button(label="Remove Selected", command=self.remove_selected_from_spine_list, width=140)
        cmds.button(label="Clear All", command=self.clear_spine_list, width=140)
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # rowLayout
        
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(140, 60, 140, 60), adjustableColumn=2)
        cmds.text(label="Invert rotateY:")
        self.invert_y_chk = cmds.checkBox(label='', value=self.spine_invert_y_default)
        cmds.text(label="Invert rotateZ:")
        self.invert_z_chk = cmds.checkBox(label='', value=self.spine_invert_z_default)
        cmds.setParent('..')  # rowLayout
        # Action button for manual spine inversion
        cmds.separator(height=6)
        cmds.button(label="Invert Spine Channels on Selection", command=self.invert_spine_channels)
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout

        cmds.separator(height=10)
        cmds.button(label="Load Default Biped Controls", command=self.load_biped_defaults)
        cmds.button(label="Load Default Quadruped Controls", command=self.load_quad_defaults)
    
    def setup_copy_offset_tab(self):
        """Setup the Copy with Offset functionality tab."""
        cmds.text(label="Copy with Time and Value Offset", font="boldLabelFont")
        cmds.separator(height=10)
        
        cmds.text(label="Select source control first, then target controls", font="smallPlainLabelFont")
        cmds.separator(height=10)
        
        # Offset controls
        cmds.frameLayout(label="Offset Settings", collapsable=False, marginHeight=6, marginWidth=6)
        cmds.columnLayout(adjustableColumn=True, rowSpacing=4)
        
        cmds.rowLayout(numberOfColumns=4, columnWidth4=(120, 80, 120, 80), adjustableColumn=2)
        cmds.text(label="Time Offset (frames):")
        self.time_offset_copy_field = cmds.intField(value=10)
        cmds.text(label="Value Offset:")
        self.value_offset_copy_field = cmds.floatField(value=0.0, precision=3)
        cmds.setParent('..')
        
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout
        
        cmds.separator(height=10)
        
        # Channel selection
        cmds.frameLayout(label="Channel Selection", collapsable=False, marginHeight=6, marginWidth=6)
        cmds.columnLayout(adjustableColumn=True, rowSpacing=4)
        
        cmds.text(label="Translation Channels:")
        cmds.rowLayout(numberOfColumns=6, columnWidth6=(80, 80, 80, 80, 80, 80))
        cmds.text(label="X:")
        self.translate_x_chk = cmds.checkBox(label='', value=True)
        cmds.text(label="Y:")
        self.translate_y_chk = cmds.checkBox(label='', value=True)
        cmds.text(label="Z:")
        self.translate_z_chk = cmds.checkBox(label='', value=True)
        cmds.setParent('..')
        
        cmds.separator(height=5)
        cmds.text(label="Rotation Channels:")
        cmds.rowLayout(numberOfColumns=6, columnWidth6=(80, 80, 80, 80, 80, 80))
        cmds.text(label="X:")
        self.rotate_x_chk = cmds.checkBox(label='', value=True)
        cmds.text(label="Y:")
        self.rotate_y_chk = cmds.checkBox(label='', value=True)
        cmds.text(label="Z:")
        self.rotate_z_chk = cmds.checkBox(label='', value=True)
        cmds.setParent('..')
        
        cmds.separator(height=5)
        cmds.rowLayout(numberOfColumns=2, columnWidth2=(150, 150))
        cmds.button(label="Select All", command=self.select_all_channels)
        cmds.button(label="Deselect All", command=self.deselect_all_channels)
        cmds.setParent('..')
        
        cmds.setParent('..')  # columnLayout
        cmds.setParent('..')  # frameLayout
        
        cmds.separator(height=15)
        
        # Copy button
        cmds.button(label="Copy with Offset", command=self.copy_with_offset, height=35, 
                   backgroundColor=(0.4, 0.6, 0.4))

    # =========================================================================
    # SECTION 2: CONTROL MANAGEMENT
    # =========================================================================

    def add_selected_controls(self, *_):
        sel = cmds.ls(selection=True)
        if not sel:
            cmds.warning("No controls selected.")
            return
            
        # Auto-detect and update rig prefix from first selected control
        first_ctrl = sel[0]
        detected_prefix = self.extract_rig_prefix(first_ctrl)
        current_prefix = cmds.textField(self.prefix_field, query=True, text=True)
        
        # Update prefix if it's different from current or if current is default
        if detected_prefix != current_prefix or current_prefix == "tigerA_rigMain_01_:":
            cmds.textField(self.prefix_field, edit=True, text=detected_prefix)
            if detected_prefix:
                cmds.inViewMessage(amg=f"Rig prefix auto-detected: {detected_prefix}", pos='midCenter', fade=True)
            else:
                cmds.inViewMessage(amg="No namespace detected in selection", pos='midCenter', fade=True)
        
        for ctrl in sel:
            ctrl_short = ctrl.split(':')[-1] if ':' in ctrl else ctrl
            if self.is_left(ctrl_short):
                right_ctrl = self.get_other_side(ctrl_short, left_to_right=True)
                # Maintain paired alignment
                if ctrl_short not in self.left_controls and right_ctrl and right_ctrl not in self.right_controls:
                    self.left_controls.append(ctrl_short)
                    self.right_controls.append(right_ctrl)
                    cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
                else:
                    # If lists already contain one side, try to align by index
                    if ctrl_short not in self.left_controls:
                        self.left_controls.append(ctrl_short)
                        cmds.textScrollList(self.left_list_field, edit=True, append=ctrl_short)
                    if right_ctrl and right_ctrl not in self.right_controls:
                        self.right_controls.append(right_ctrl)
                        cmds.textScrollList(self.right_list_field, edit=True, append=right_ctrl)
            elif self.is_right(ctrl_short):
                left_ctrl = self.get_other_side(ctrl_short, left_to_right=False)
                if ctrl_short not in self.right_controls and left_ctrl and left_ctrl not in self.left_controls:
                    self.right_controls.append(ctrl_short)
                    self.left_controls.append(left_ctrl)
                    cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
                else:
                    if ctrl_short not in self.right_controls:
                        self.right_controls.append(ctrl_short)
                        cmds.textScrollList(self.right_list_field, edit=True, append=ctrl_short)
                    if left_ctrl and left_ctrl not in self.left_controls:
                        self.left_controls.append(left_ctrl)
                        cmds.textScrollList(self.left_list_field, edit=True, append=left_ctrl)
            else:
                cmds.warning(f"Control name does not match left/right pattern: {ctrl_short}")

    def remove_selected_controls(self, *_):
        left_selected = cmds.textScrollList(self.left_list_field, query=True, selectItem=True) or []
        right_selected = cmds.textScrollList(self.right_list_field, query=True, selectItem=True) or []
        for ctrl in left_selected:
            cmds.textScrollList(self.left_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.left_controls:
                self.left_controls.remove(ctrl)
            right_ctrl = self.get_other_side(ctrl, left_to_right=True)
            if right_ctrl:
                cmds.textScrollList(self.right_list_field, edit=True, removeItem=right_ctrl)
                if right_ctrl in self.right_controls:
                    self.right_controls.remove(right_ctrl)
        for ctrl in right_selected:
            cmds.textScrollList(self.right_list_field, edit=True, removeItem=ctrl)
            if ctrl in self.right_controls:
                self.right_controls.remove(ctrl)
            left_ctrl = self.get_other_side(ctrl, left_to_right=False)
            if left_ctrl:
                cmds.textScrollList(self.left_list_field, edit=True, removeItem=left_ctrl)
                if left_ctrl in self.left_controls:
                    self.left_controls.remove(left_ctrl)

    # =========================================================================
    # SECTION 3: UTILITY FUNCTIONS & ANIMATION HELPERS
    # =========================================================================

    # ---------------------
    # String manipulation utilities  
    # ---------------------
    def is_left(self, name):
        """Check if control name indicates left side (L_ or _L patterns)."""
        return bool(re.search(r"(^|:|_)L(_|$)", name))

    def is_right(self, name):
        """Check if control name indicates right side (R_ or _R patterns)."""
        return bool(re.search(r"(^|:|_)R(_|$)", name))

    def get_other_side(self, name, left_to_right=True):
        """Convert left control name to right (or vice versa)."""
        if left_to_right:
            # Handle both L_ and _L patterns
            name = re.sub(r"(^|:|_)L_", r"\1R_", name)
            name = re.sub(r"_L$", "_R", name)
            return name
        else:
            # Handle both R_ and _R patterns  
            name = re.sub(r"(^|:|_)R_", r"\1L_", name)
            name = re.sub(r"_R$", "_L", name)
            return name

    def extract_rig_prefix(self, control_name):
        """Extract the rig prefix/namespace from a control name.
        Examples: 
        - 'the_tyrant_rig:IKLeg_R' -> 'the_tyrant_rig:'
        - 'tigerA_rigMain_01_:L_arm_CTL' -> 'tigerA_rigMain_01_:'
        - 'IKLeg_R' -> ''
        """
        if ':' in control_name:
            return control_name.split(':', 1)[0] + ':'
        return ''

    # ---------------------
    # Animation curve utilities
    # ---------------------
    def _anim_curve_for_attr(self, attr_plug):
        """Return the first animCurve node connected to the given attribute plug.
        attr_plug is like 'node.attr'. Returns None if not found.
        """
        # Prefer robust query that traverses through utility nodes
        try:
            curves = cmds.keyframe(attr_plug, query=True, name=True) or []
            if curves:
                return curves[0]
        except Exception:
            pass

        # Fallback: direct connections
        conns = cmds.listConnections(attr_plug, s=True, d=False) or []
        for n in conns:
            try:
                nt = cmds.nodeType(n)
            except Exception:
                continue
            if isinstance(nt, str) and nt.startswith('animCurve'):
                return n
        return None

    def _apply_cycle_infinity_mel(self, curves):
        """Apply cycle infinity to animation curves using MEL commands.
        This is more reliable than the Python cmds.setInfinity approach.
        """
        if not curves:
            return

        # Normalize to list
        if isinstance(curves, str):
            curves = [curves]

        for curve in curves:
            if not curve or not cmds.objExists(curve):
                continue
            # Some animCurve types use preInfinity/postInfinity enum (int). 2 == cycle
            for attr_name, label in (("preInfinity", "pre"), ("postInfinity", "post")):
                try:
                    locked = cmds.getAttr(f"{curve}.{attr_name}", lock=True)
                except Exception:
                    locked = False
                if locked:
                    try:
                        cmds.setAttr(f"{curve}.{attr_name}", lock=False)
                    except Exception as e:
                        continue
                try:
                    before = cmds.getAttr(f"{curve}.{attr_name}")
                except Exception:
                    before = "?"
                # Direct setAttr (0=constant,1=linear,2=cycle,3=cycleRelative,4=oscillate)
                try:
                    cmds.setAttr(f"{curve}.{attr_name}", 3)
                except Exception as e:
                    # Fallback: attempt MEL targeted at curve
                    try:
                        import maya.mel as mel
                        mel.eval(f"select -r {curve};")
                        if label == 'pre':
                            mel.eval("setInfinity -pri cycle;")
                        else:
                            mel.eval("setInfinity -poi cycle;")
                    except Exception as me:
                        pass
                try:
                    after = cmds.getAttr(f"{curve}.{attr_name}")
                except Exception:
                    after = "?"
                # Relock if it was locked originally
                if locked:
                    try:
                        cmds.setAttr(f"{curve}.{attr_name}", lock=True)
                    except Exception:
                        pass

    # =========================================================================
    # SECTION 5: INFINITY MANAGEMENT
    # =========================================================================

    def _apply_cycle_infinity_advanced(self, curves, verbose=True):
        """Attempt to set pre/post infinity to cycle with multiple strategies and diagnostics.
        Strategies per curve:
          1. Direct setInfinity command with full parameter specification
          2. Direct setAttr (int 2)
          3. cmds.setInfinity(preInfinite='cycle', postInfinite='cycle')
          4. OpenMaya API plug set (setInt)
        Batch strategies (all curves):
          5. MEL batch: select all curves once, set both pri & poi simultaneously
        Diagnostics:
          - keyframe count & times
          - reference status & node lock state
          - original and final values
          - single-key warning (cycle visually meaningless with <2 keys)
        Returns (updated, failed) lists.
        """
        if not curves:
            return [], []
        # Normalize
        if isinstance(curves, str):
            curves = [curves]
        updated = []
        pending = []
        
        # Pre-pass collect info
        for c in curves:
            if not cmds.objExists(c):
                if verbose:
                    print(f"INFINITY_ADV: Curve missing {c}")
                continue
            
            # Try direct setInfinity command first with all parameters
            try:
                # This applies to all keyframe tangents on the curve
                cmds.setInfinity(c, preInfinite="cycle", postInfinite="cycle", 
                                controlPoints=True, shape=True, hierarchy="none")
                
                # Verify it worked
                pre_val = cmds.getAttr(c+'.preInfinity')
                post_val = cmds.getAttr(c+'.postInfinity')
                if pre_val == 3 and post_val == 3:
                    if verbose:
                        print(f"INFINITY_ADV: Direct setInfinity with params success {c}")
                    updated.append(c)
                    continue
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: Direct setInfinity with params failed {c}: {e}")
            
            try:
                kt = cmds.keyframe(c, query=True, timeChange=True) or []
            except Exception:
                kt = []
            kcount = len(kt)
            try:
                ref = cmds.referenceQuery(c, isNodeReferenced=True)
            except Exception:
                ref = False
            try:
                locked_node = cmds.lockNode(c, query=True, lock=True) or [False]
                locked_node = any(locked_node)
            except Exception:
                locked_node = False
            try:
                pre0 = cmds.getAttr(c+'.preInfinity')
                post0 = cmds.getAttr(c+'.postInfinity')
            except Exception:
                pre0 = post0 = '??'
            if verbose:
                rng = (min(kt), max(kt)) if kcount else (None, None)
                print(f"INFINITY_ADV: {c} type={cmds.nodeType(c)} keys={kcount} range={rng} ref={ref} lockedNode={locked_node} pre={pre0} post={post0}")
            # Try direct setAttr command first
            success_direct = False
            for attr in ('preInfinity','postInfinity'):
                try:
                    cmds.setAttr(f'{c}.{attr}', 3)
                except Exception as e:
                    if verbose:
                        print(f"INFINITY_ADV: setAttr failed {c}.{attr}: {e}")
            try:
                preA = cmds.getAttr(c+'.preInfinity')
                postA = cmds.getAttr(c+'.postInfinity')
                success_direct = (preA == 3 and postA == 3)
            except Exception:
                success_direct = False
            if success_direct:
                if verbose:
                    print(f"INFINITY_ADV: Direct setAttr success {c} -> (2,2)")
                updated.append(c)
                continue
            # Try cmds.setInfinity
            try:
                cmds.setInfinity(c, preInfinite='cycle', postInfinite='cycle')
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: cmds.setInfinity failed {c}: {e}")
            try:
                preB = cmds.getAttr(c+'.preInfinity')
                postB = cmds.getAttr(c+'.postInfinity')
                if preB == 3 and postB == 3:
                    if verbose:
                        print(f"INFINITY_ADV: cmds.setInfinity success {c}")
                    updated.append(c)
                    continue
            except Exception:
                pass
            # Try OpenMaya API
            try:
                import maya.api.OpenMaya as om
                sel = om.MSelectionList(); sel.add(c)
                mobj = sel.getDependNode(0)
                fn = om.MFnDependencyNode(mobj)
                for attr in ('preInfinity','postInfinity'):
                    plug = fn.findPlug(attr, False)
                    plug.setInt(3)
                preC = cmds.getAttr(c+'.preInfinity')
                postC = cmds.getAttr(c+'.postInfinity')
                if preC == 3 and postC == 3:
                    if verbose:
                        print(f"INFINITY_ADV: OpenMaya plug success {c}")
                    updated.append(c)
                    continue
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: OpenMaya attempt failed {c}: {e}")
            # Record for batch MEL attempt
            pending.append(c)
        # Batch MEL (single selection) if any pending
        if pending:
            if verbose:
                print(f"INFINITY_ADV: Batch MEL attempt on {len(pending)} pending curves")
            try:
                import maya.mel as mel
                mel.eval('select -r ' + ' '.join(pending) + ';')
                # Single call specifying both flags sometimes behaves differently than split calls
                mel.eval('setInfinity -pri 2 -poi 2;')  # numeric flags
                # Also try named for safety
                mel.eval('setInfinity -pri "cycle" -poi "cycle";')
            except Exception as e:
                if verbose:
                    print(f"INFINITY_ADV: Batch MEL failure: {e}")
            # Re-check
            recheck = []
            for c in list(pending):
                try:
                    if cmds.getAttr(c+'.preInfinity') == 3 and cmds.getAttr(c+'.postInfinity') == 3:
                        updated.append(c)
                    else:
                        recheck.append(c)
                except Exception:
                    recheck.append(c)
            pending = recheck
        # Single-key warning
        for c in list(pending):
            try:
                kcount = cmds.keyframe(c, query=True, keyframeCount=True)
                if kcount < 2:
                    if verbose:
                        print(f"INFINITY_ADV: {c} has <2 keys; cycling pre/post may be suppressed by Maya.")
            except Exception:
                pass
        return updated, pending

    # ---------------------
    # Manual infinity application
    # ---------------------
    def _collect_anim_curves_from_nodes(self, nodes):
        curves = []
        for node in nodes:
            if not cmds.objExists(node):
                continue
            # Method 1: keyframe query
            try:
                kcurves = cmds.keyframe(node, query=True, name=True) or []
                for c in kcurves:
                    if c not in curves:
                        curves.append(c)
            except Exception:
                pass
            # Method 2: listConnections by animCurve
            try:
                conns = cmds.listConnections(node, source=True, destination=False) or []
                for c in conns:
                    try:
                        if cmds.objExists(c) and cmds.nodeType(c).startswith('animCurve') and c not in curves:
                            curves.append(c)
                    except Exception:
                        continue
            except Exception:
                pass
        return curves

    def apply_cycle_infinity_for_selection(self, *_):
        sel = cmds.ls(selection=True) or []
        if not sel:
            cmds.warning("Select controls or animCurves to apply cycle infinity.")
            return

        # Ensure 2+ keys is now always enabled by default
        ensure_two_keys = True

        direct_curves = [s for s in sel if cmds.objExists(s) and cmds.nodeType(s).startswith('animCurve')]
        target_nodes = [s for s in sel if s not in direct_curves]
        curves = list(direct_curves)
        curves += self._collect_anim_curves_from_nodes(target_nodes)
        curves = list(dict.fromkeys(curves))  # unique preserve

        if ensure_two_keys:
            for curve in curves:
                self._ensure_two_keys(curve)

        if not curves:
            cmds.warning("No animCurves found on selection.")
            return

        updated, failed = self._apply_cycle_infinity_advanced(curves, verbose=False)

        # Always generate the manual script for all curves
        self.generate_manual_infinity_script(curves)

        if updated and not failed:
            cmds.inViewMessage(amg=f"Applied cycle infinity to {len(updated)} curve(s)", pos='midCenter', fade=True)
        elif updated:
            cmds.inViewMessage(amg=f"Cycle infinity partial: {len(updated)}/{len(curves)}", pos='midCenter', fade=True)

    def generate_manual_infinity_script(self, curves):
        """Generate a script to manually apply infinity settings to the given curves."""
        if not curves:
            print("No curves provided to generate a manual script.")
            return

        script_lines = []
        for curve in curves:
            if cmds.objExists(curve):
                script_lines.append(f"cmds.setAttr('{curve}.preInfinity', 3)")
                script_lines.append(f"cmds.setAttr('{curve}.postInfinity', 3)")

        if script_lines:
            print("\n# Generated script to manually apply infinity settings:\n")
            for line in script_lines:
                print(line)
            print("\n# End of script\n")
        else:
            print("No valid curves found to generate a script.")

    def _apply_infinity_from_source(self, source_curve, target_curve):
        """Copy pre/post infinity from source_curve to target_curve.
        If force_cycle is enabled, applies cycle infinity instead.
        """
        if not source_curve or not target_curve:
            return
            
        # Force cycle infinity is now always enabled by default
        force_cycle = True
            
        if force_cycle:
            # Force cycle using direct attr method
            self._apply_cycle_infinity_mel([target_curve])
            return
            
        try:
            pre_val = cmds.getAttr('{}.preInfinity'.format(source_curve))
            post_val = cmds.getAttr('{}.postInfinity'.format(source_curve))
        except Exception:
            return
        inf_map = {0: 'constant', 1: 'linear', 2: 'cycle', 3: 'cycleRelative', 4: 'oscillate'}
        pre_str = inf_map.get(pre_val, 'constant')
        post_str = inf_map.get(post_val, 'constant')

        try:
            # Select the curve and use MEL commands for reliability
            cmds.select(target_curve, replace=True)
            import maya.mel as mel
            mel.eval(f"setInfinity -pri {pre_str};")
            mel.eval(f"setInfinity -poi {post_str};")
            cmds.select(clear=True)
        except Exception:
            # Fallback to direct attribute setting
            try:
                cmds.setAttr('{}.preInfinity'.format(target_curve), pre_val)
                cmds.setAttr('{}.postInfinity'.format(target_curve), post_val)
            except Exception:
                pass

    def _keyed_attributes(self, node):
        """Return a list of attribute names on node that have connected animCurves."""
        attrs = []
        try:
            curves = cmds.keyframe(node, query=True, name=True) or []
        except Exception:
            curves = []
        if not curves:
            return attrs
        for c in set(curves):
            try:
                dest_plugs = cmds.listConnections(c + '.output', s=False, d=True, p=True) or []
            except Exception:
                dest_plugs = []
            for plug in dest_plugs:
                if plug.startswith(node + '.'):
                    attrs.append(plug.split('.')[-1])
        return list(dict.fromkeys(attrs))  # unique, preserve order

    # =========================================================================
    # SECTION 8: SPINE/CENTERLINE PROCESSING
    # =========================================================================

    def _get_spine_controls(self):
        """Return list of spine controls from UI."""
        try:
            return cmds.textScrollList(self.spine_controls_list, query=True, allItems=True) or []
        except Exception:
            return []
    
    def add_selected_to_spine_list(self, *_):
        """Add currently selected objects to the spine controls list."""
        selected = cmds.ls(selection=True) or []
        if not selected:
            cmds.warning("No objects selected to add to spine controls list.")
            return
        
        current_items = cmds.textScrollList(self.spine_controls_list, query=True, allItems=True) or []
        
        added_count = 0
        for item in selected:
            if item not in current_items:
                cmds.textScrollList(self.spine_controls_list, edit=True, append=item)
                added_count += 1
        
        print(f"Added {added_count} controls to spine list")
    
    def remove_selected_from_spine_list(self, *_):
        """Remove selected items from the spine controls list."""
        selected_items = cmds.textScrollList(self.spine_controls_list, query=True, selectItem=True) or []
        if not selected_items:
            cmds.warning("No items selected in the spine controls list to remove.")
            return
        
        for item in selected_items:
            cmds.textScrollList(self.spine_controls_list, edit=True, removeItem=item)
        
        print(f"Removed {len(selected_items)} controls from spine list")
    
    def clear_spine_list(self, *_):
        """Clear all items from the spine controls list."""
        cmds.textScrollList(self.spine_controls_list, edit=True, removeAll=True)
        print("Cleared all controls from spine list")

    def _should_invert_for_spine(self, node_name, attr):
        """True if node matches spine controls list and attr is selected for inversion (rotateY/rotateZ)."""
        spine_controls = self._get_spine_controls()
        if node_name not in spine_controls:
            return False
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default
        if attr == 'rotateY' and invert_y:
            return True
        if attr == 'rotateZ' and invert_z:
            return True
        return False

    def _playback_cycle_range(self):
        """Return (start, end, mid) from playback options, fallback to (0,40,20)."""
        try:
            start = float(cmds.playbackOptions(query=True, min=True))
            end = float(cmds.playbackOptions(query=True, max=True))
        except Exception:
            start, end = 0.0, 40.0
        if end <= start:
            end = start + 40.0
        mid = (start + end) / 2.0
        return start, end, mid

    def _has_key_at(self, plug, t):
        """Return True if there's a key on plug at time t."""
        try:
            times = cmds.keyframe(plug, query=True, time=(t, t), timeChange=True) or []
            return any(abs(tt - t) < 1e-4 for tt in times)
        except Exception:
            return False

    def _ensure_key(self, plug, t, value=None):
        """Ensure a key exists at time t with a given value (or current eval if None)."""
        try:
            if value is None:
                value = cmds.getAttr(plug, time=t)
            cmds.setKeyframe(plug, time=t, value=value)
        except Exception:
            pass

    def _rebuild_second_half_antiphase(self, plug, start, mid, end):
        """Make [mid,end] equal to the negative of [start,mid] for the given plug."""
        # Anchor values
        try:
            v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = None
        if not self._has_key_at(plug, start):
            self._ensure_key(plug, start, v_start)
        if not self._has_key_at(plug, mid):
            # Create a temp key at mid to aid paste alignment
            self._ensure_key(plug, mid, v_start if v_start is not None else None)

        # Unlock if needed
        relock = False
        try:
            if cmds.getAttr(plug, lock=True):
                relock = True
                cmds.setAttr(plug, lock=False)
        except Exception:
            pass

        # Clear second half
        try:
            cmds.cutKey(plug, time=(mid, end))
        except Exception:
            pass

        # Copy first half [start, mid) and paste to [mid, end)
        try:
            cmds.copyKey(plug, time=(start, mid), includeUpperBound=False)
        except Exception as e:
            cmds.warning(f"copyKey failed on {plug} [{start},{mid}): {e}")
            return
        try:
            # Merge to avoid wiping existing keys in the first half
            cmds.pasteKey(plug, option='merge', timeOffset=(mid - start))
        except Exception as e:
            # Fallback minimal paste
            try:
                cmds.pasteKey(plug, option='merge')
            except Exception as e2:
                cmds.warning(f"pasteKey failed on {plug}: {e2}")
                return

        # Negate pasted second half
        try:
            cmds.scaleKey(plug, time=(mid, end), valueScale=-1.0)
        except Exception as e:
            cmds.warning(f"scaleKey invert failed on {plug}: {e}")

        # Enforce anchors: end==start, mid==-start
        try:
            if v_start is None:
                v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = 0.0
        self._ensure_key(plug, mid, -float(v_start))
        self._ensure_key(plug, end, float(v_start))

        # Relock
        if relock:
            try:
                cmds.setAttr(plug, lock=True)
            except Exception:
                pass

    def _ensure_two_keys(self, curve):
        """Ensure the given curve has at least two keys."""
        try:
            key_times = cmds.keyframe(curve, query=True, timeChange=True) or []
            if len(key_times) < 2:
                value = cmds.keyframe(curve, query=True, valueChange=True)[0]
                playback_start = cmds.playbackOptions(query=True, min=True)
                playback_end = cmds.playbackOptions(query=True, max=True)
                cmds.setKeyframe(curve, time=playback_start, value=value)
                cmds.setKeyframe(curve, time=playback_end, value=value)
        except Exception:
            pass

    # =========================================================================
    # SECTION 6: ANIMATION CORE FUNCTIONS
    # =========================================================================

    def get_key_options(self):
        """Get common key options for copy/paste operations."""
        # Calculate time offset as half the cycle length (time range)
        try:
            start_time = cmds.playbackOptions(query=True, min=True)
            end_time = cmds.playbackOptions(query=True, max=True)
            time_offset = (end_time - start_time) / 2.0
        except Exception:
            time_offset = 20  # Default fallback
        
        return {
            "option": "replaceCompletely",
            "copies": 1,
            "timeOffset": time_offset,
            # Only include flags supported by pasteKey
        }

    def copy_keys(self, source_ctrl, target_ctrl):
        """Copy keys from source to target control with auto-inversion and infinity handling."""
        # Validate and get full control names
        source_full, target_full = self._get_full_control_names(source_ctrl, target_ctrl)
        if not source_full or not target_full:
            return
            
        # Safety check: don't copy to same control
        if source_full == target_full:
            cmds.warning(f"Source and target resolve to the same node '{source_full}'. Skipping.")
            return
        
        if not (cmds.objExists(source_full) and cmds.objExists(target_full)):
            cmds.warning(f"Control not found: {source_full} or {target_full}")
            return
            
        # Get animated attributes and copy each one
        source_keyed_attrs = self._keyed_attributes(source_full)
        if not source_keyed_attrs:
            cmds.warning(f"No keyed attributes found on source {source_full}.")
            return
            
        copied_any = False
        for attr in source_keyed_attrs:
            if self._copy_single_attribute(source_full, target_full, attr, source_ctrl, target_ctrl):
                copied_any = True
                
        if not copied_any:
            cmds.warning(f"No matching attributes on target {target_full} for source keyed attributes: {source_keyed_attrs}")

    def _get_full_control_names(self, source_ctrl, target_ctrl):
        """Get full control names including prefix."""
        prefix = cmds.textField(self.prefix_field, query=True, text=True)
        source_full = f"{prefix}{source_ctrl}" if not source_ctrl.startswith(prefix) else source_ctrl
        target_full = f"{prefix}{target_ctrl}" if not target_ctrl.startswith(prefix) else target_ctrl
        return source_full, target_full
        
    def _copy_single_attribute(self, source_full, target_full, attr, source_ctrl, target_ctrl):
        """Copy animation for a single attribute from source to target."""
        source_attr = f"{source_full}.{attr}"
        target_attr = f"{target_full}.{attr}"
        
        # Skip if target doesn't have this attribute
        if not self._target_has_attribute(target_full, attr):
            return False
            
        # Get source animation curve
        source_curve = self._anim_curve_for_attr(source_attr)
        if not source_curve:
            return False
            
        # Copy and paste the keys
        if not self._copy_and_paste_keys(source_attr, target_attr, source_curve):
            return False
            
        # Apply post-processing (inversion, infinity)
        self._apply_post_processing(target_attr, attr, source_ctrl, target_ctrl, source_curve)
        return True
        
    def _target_has_attribute(self, target_full, attr):
        """Check if target control has the specified attribute."""
        try:
            return cmds.attributeQuery(attr, node=target_full, exists=True)
        except Exception:
            return False
            
    def _copy_and_paste_keys(self, source_attr, target_attr, source_curve):
        """Copy keys from source to target attribute."""
        # Get time range
        time_range = cmds.keyframe(source_curve, query=True, timeChange=True)
        if not time_range:
            return False
            
        start_t = min(time_range)
        end_t = max(time_range)
        
        # Copy keys from source
        try:
            cmds.copyKey(source_attr, time=(start_t, end_t), includeUpperBound=True)
        except Exception as e:
            cmds.warning(f"copyKey failed on {source_attr}: {e}")
            return False
            
        # Handle locked attributes
        relock = self._handle_attribute_lock(target_attr, unlock=True)
        
        # Paste keys with fallback
        paste_success = self._paste_keys_with_fallback(target_attr)
        
        # Restore lock state
        if relock:
            self._handle_attribute_lock(target_attr, lock=True)
            
        return paste_success
        
    def _handle_attribute_lock(self, attr, unlock=False, lock=False):
        """Handle locking/unlocking of attributes. Returns True if attribute was locked."""
        try:
            is_locked = cmds.getAttr(attr, lock=True)
            if unlock and is_locked:
                cmds.setAttr(attr, lock=False)
                return True
            elif lock:
                cmds.setAttr(attr, lock=True)
        except Exception:
            pass
        return False
        
    def _paste_keys_with_fallback(self, target_attr):
        """Paste keys with fallback options."""
        paste_opts = self.get_key_options()
        
        # Primary paste attempt
        try:
            cmds.pasteKey(target_attr, **paste_opts)
            cmds.refresh()  # Allow Maya to process
            return True
        except Exception as e:
            cmds.warning(f"pasteKey failed on {target_attr}: {e}")
            
        # Fallback paste attempt
        try:
            cmds.pasteKey(target_attr, option='replaceCompletely')
            cmds.refresh()
            return True
        except Exception as e2:
            cmds.warning(f"pasteKey fallback failed on {target_attr}: {e2}")
            return False
            
    def _apply_post_processing(self, target_attr, attr, source_ctrl, target_ctrl, source_curve):
        """Apply X-axis inversion and infinity settings after key paste."""
        # Apply auto-inversion for translateX
        if self.auto_detect_x_inversion and attr == 'translateX':
            self._apply_auto_x_inversion(target_attr, source_ctrl, target_ctrl)
            
        # Apply infinity settings
        self._apply_infinity_to_target(target_attr, source_curve)
        
    def _apply_auto_x_inversion(self, target_attr, source_ctrl, target_ctrl):
        """Apply automatic X-axis inversion if needed."""
        try:
            # Check if this is a left<->right pair
            source_is_left = self.is_left(source_ctrl)
            source_is_right = self.is_right(source_ctrl)
            target_is_left = self.is_left(target_ctrl)
            target_is_right = self.is_right(target_ctrl)
            
            if not ((source_is_left and target_is_right) or (source_is_right and target_is_left)):
                return  # Not a left<->right pair
                
            # Detect and apply inversion if needed
            inversion_needed = self.detect_x_inversion_needed(source_ctrl, target_ctrl)
            if inversion_needed:
                cmds.scaleKey(target_attr, valueScale=-1.0)
                print(f"Applied X-axis inversion to {target_attr}")
            else:
                print(f"No X-axis inversion needed for {target_attr}")
                
        except Exception as e:
            cmds.warning(f"Auto-inversion detection failed for {target_attr}: {e}")
            
    def _apply_infinity_to_target(self, target_attr, source_curve):
        """Apply infinity settings and tangent smoothing to target attribute curves."""
        target_curves = self._find_target_curves(target_attr)
        if not target_curves:
            print(f"DEBUG: WARNING - No curves found for {target_attr}")
            return
            
        # Force cycle infinity is now always enabled by default
        force_cycle = True
            
        if force_cycle:
            self._apply_cycle_infinity_mel(target_curves)
        else:
            for target_curve in target_curves:
                self._apply_infinity_from_source(source_curve, target_curve)
        
        # Apply tangent smoothing for seamless cycling
        self._apply_tangent_smoothing_to_curves(target_curves)
    
    def _apply_tangent_smoothing_to_curves(self, curves):
        """Apply tangent smoothing to curves using their full time range."""
        if not curves:
            return
            
        for curve in curves:
            if not curve or not cmds.objExists(curve):
                continue
                
            try:
                # Get the full time range of this curve
                key_times = cmds.keyframe(curve, query=True, timeChange=True) or []
                if len(key_times) < 2:
                    continue
                    
                start_time = min(key_times)
                end_time = max(key_times)
                
                # Apply smooth cycle tangents
                self._ensure_smooth_cycle_tangents([curve], start_time, end_time)
                
            except Exception as e:
                print(f"DEBUG: Error applying tangent smoothing to {curve}: {e}")
                
    def _find_target_curves(self, target_attr):
        """Find animation curves connected to target attribute using multiple methods."""
        # Method 1: keyframe query
        try:
            curves = cmds.keyframe(target_attr, query=True, name=True) or []
            if curves:
                return curves
        except Exception:
            pass
            
        # Method 2: listConnections with animCurve type filter
        try:
            conns = cmds.listConnections(target_attr, source=True, destination=False, type='animCurve') or []
            curves = [c for c in conns if c and cmds.objExists(c) and cmds.nodeType(c).startswith('animCurve')]
            if curves:
                return curves
        except Exception:
            pass
            
        # Method 3: General listConnections and filter
        try:
            all_conns = cmds.listConnections(target_attr, source=True, destination=False) or []
            curves = []
            for conn in all_conns:
                if conn and cmds.objExists(conn):
                    try:
                        if cmds.nodeType(conn).startswith('animCurve'):
                            curves.append(conn)
                    except Exception:
                        continue
            return curves
        except Exception:
            pass
            
        return []

    # =========================================================================
    # SECTION 7: COPY OPERATIONS
    # =========================================================================

    def copy_left_to_right(self, *_):
        """Copy animation from left controls to right controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            left_ctrl = self.left_controls[i]
            # Prefer the explicit paired right control; fallback to name swap if missing/empty
            right_ctrl = self.right_controls[i] if i < len(self.right_controls) and self.right_controls[i] else self.get_other_side(left_ctrl, left_to_right=True)
            if left_ctrl == right_ctrl:
                cmds.warning(f"Skipping pair with identical names: {left_ctrl}")
                continue
            self.copy_keys(left_ctrl, right_ctrl)

    def copy_right_to_left(self, *_):
        """Copy animation from right controls to left controls."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("Left or Right list is empty. Please add paired controls first.")
            return

        count = min(len(self.left_controls), len(self.right_controls))
        if len(self.left_controls) != len(self.right_controls):
            cmds.warning(f"Left/Right list lengths differ (L={len(self.left_controls)} R={len(self.right_controls)}). Using first {count} pairs.")

        for i in range(count):
            right_ctrl = self.right_controls[i]
            # Prefer the explicit paired left control; fallback to name swap if missing/empty
            left_ctrl = self.left_controls[i] if i < len(self.left_controls) and self.left_controls[i] else self.get_other_side(right_ctrl, left_to_right=False)
            if right_ctrl == left_ctrl:
                cmds.warning(f"Skipping pair with identical names: {right_ctrl}")
                continue
            self.copy_keys(right_ctrl, left_ctrl)





    # =========================================================================
    # SECTION 4: X-AXIS INVERSION DETECTION SYSTEM
    # =========================================================================

    def detect_x_inversion_needed(self, left_ctrl, right_ctrl, verbose=False):
        """
        Analyze existing animation on left/right control pair to determine if X-axis inversion is needed.
        
        Returns:
            bool: True if X-axis values should be inverted when copying, False if they should stay the same
            
        Logic:
        - If left moves +X and right moves +X at the same time -> need inversion (opposite rig convention)
        - If left moves +X and right moves -X at the same time -> no inversion needed (mirrored rig convention)
        """
        # Check cache first
        cache_key = (left_ctrl, right_ctrl)
        if cache_key in self.x_inversion_cache:
            if verbose:
                cached_result = self.x_inversion_cache[cache_key]
                print(f"Using cached inversion result for {left_ctrl}<->{right_ctrl}: {cached_result}")
            return self.x_inversion_cache[cache_key]
        
        prefix = cmds.textField(self.prefix_field, query=True, text=True)
        left_full = f"{prefix}{left_ctrl}" if not left_ctrl.startswith(prefix) else left_ctrl
        right_full = f"{prefix}{right_ctrl}" if not right_ctrl.startswith(prefix) else right_ctrl
        
        if not (cmds.objExists(left_full) and cmds.objExists(right_full)):
            if verbose:
                print(f"Controls don't exist: {left_full} or {right_full}")
            return False
        
        # Analyze translateX patterns
        inversion_needed = self._analyze_translate_x_patterns(left_full, right_full, verbose)
        
        # If translateX analysis is inconclusive, try rotation analysis
        if inversion_needed is None:
            inversion_needed = self._analyze_rotation_patterns(left_full, right_full, verbose)
        
        # Default to False if still inconclusive
        if inversion_needed is None:
            inversion_needed = False
            if verbose:
                print(f"Analysis inconclusive for {left_ctrl}<->{right_ctrl}, defaulting to no inversion")
        
        # Cache the result
        self.x_inversion_cache[cache_key] = inversion_needed
        
        if verbose:
            print(f"X-inversion analysis for {left_ctrl}<->{right_ctrl}: {'INVERT' if inversion_needed else 'NO INVERSION'}")
        
        return inversion_needed
    
    def _analyze_translate_x_patterns(self, left_full, right_full, verbose=False):
        """Analyze translateX animation patterns to detect inversion needs."""
        left_tx_attr = f"{left_full}.translateX"
        right_tx_attr = f"{right_full}.translateX"
        
        # Get animation curves for translateX
        left_curve = self._anim_curve_for_attr(left_tx_attr)
        right_curve = self._anim_curve_for_attr(right_tx_attr)
        
        if not (left_curve and right_curve):
            if verbose:
                print(f"Missing translateX animation: L={bool(left_curve)} R={bool(right_curve)}")
            return None
        
        # Get keyframe times that exist on both curves
        try:
            left_times = set(cmds.keyframe(left_curve, query=True, timeChange=True) or [])
            right_times = set(cmds.keyframe(right_curve, query=True, timeChange=True) or [])
            common_times = sorted(left_times.intersection(right_times))
            
            if len(common_times) < 2:
                if verbose:
                    print(f"Not enough common keyframes for analysis: {len(common_times)}")
                return None
            
            # Sample values at common times
            correlation_samples = []
            for time in common_times[:10]:  # Limit to first 10 samples for performance
                try:
                    left_val = cmds.getAttr(left_tx_attr, time=time)
                    right_val = cmds.getAttr(right_tx_attr, time=time)
                    correlation_samples.append((left_val, right_val))
                except Exception:
                    continue
            
            if len(correlation_samples) < 2:
                if verbose:
                    print("Not enough valid samples for correlation analysis")
                return None
            
            # Calculate correlation direction
            # If left and right move in same direction -> need inversion
            # If left and right move in opposite directions -> no inversion needed
            same_direction_count = 0
            opposite_direction_count = 0
            
            for i in range(1, len(correlation_samples)):
                left_prev, right_prev = correlation_samples[i-1]
                left_curr, right_curr = correlation_samples[i]
                
                left_delta = left_curr - left_prev
                right_delta = right_curr - right_prev
                
                # Skip if no significant movement
                if abs(left_delta) < 0.001 and abs(right_delta) < 0.001:
                    continue
                
                # Check if movements are in same direction or opposite
                if (left_delta > 0 and right_delta > 0) or (left_delta < 0 and right_delta < 0):
                    same_direction_count += 1
                elif (left_delta > 0 and right_delta < 0) or (left_delta < 0 and right_delta > 0):
                    opposite_direction_count += 1
            
            if verbose:
                print(f"TranslateX analysis: Same direction={same_direction_count}, Opposite direction={opposite_direction_count}")
            
            # Determine result based on predominant pattern
            if same_direction_count > opposite_direction_count:
                return True  # Need inversion - they move the same way but should be mirrored
            elif opposite_direction_count > same_direction_count:
                return False  # No inversion - already mirrored correctly
            else:
                return None  # Inconclusive
                
        except Exception as e:
            if verbose:
                print(f"Error in translateX analysis: {e}")
            return None
    
    def _analyze_rotation_patterns(self, left_full, right_full, verbose=False):
        """Analyze rotation patterns as fallback to translateX analysis."""
        # Check rotateY patterns (often the most telling for left/right differences)
        left_ry_attr = f"{left_full}.rotateY"
        right_ry_attr = f"{right_full}.rotateY"
        
        left_curve = self._anim_curve_for_attr(left_ry_attr)
        right_curve = self._anim_curve_for_attr(right_ry_attr)
        
        if not (left_curve and right_curve):
            if verbose:
                print(f"Missing rotateY animation: L={bool(left_curve)} R={bool(right_curve)}")
            return None
        
        try:
            # Get average values over time
            left_times = cmds.keyframe(left_curve, query=True, timeChange=True) or []
            right_times = cmds.keyframe(right_curve, query=True, timeChange=True) or []
            
            # Sample a few values
            left_samples = []
            right_samples = []
            
            for time in left_times[:5]:
                try:
                    left_samples.append(cmds.getAttr(left_ry_attr, time=time))
                except Exception:
                    pass
            
            for time in right_times[:5]:
                try:
                    right_samples.append(cmds.getAttr(right_ry_attr, time=time))
                except Exception:
                    pass
            
            if not (left_samples and right_samples):
                return None
            
            left_avg = sum(left_samples) / len(left_samples)
            right_avg = sum(right_samples) / len(right_samples)
            
            if verbose:
                print(f"RotateY averages: L={left_avg:.3f}, R={right_avg:.3f}")
            
            # If rotations have same sign, they might need inversion
            # This is a heuristic - not foolproof
            if (left_avg > 0 and right_avg > 0) or (left_avg < 0 and right_avg < 0):
                return True  # Likely need inversion
            else:
                return False  # Likely already mirrored
                
        except Exception as e:
            if verbose:
                print(f"Error in rotation analysis: {e}")
            return None
    
    def analyze_all_control_pairs(self, verbose=False):
        """Analyze all current left/right control pairs and update the inversion cache."""
        if not self.left_controls or not self.right_controls:
            cmds.warning("No control pairs to analyze")
            return
        
        results = {}
        count = min(len(self.left_controls), len(self.right_controls))
        
        print(f"Analyzing {count} control pairs for X-axis inversion needs...")
        
        for i in range(count):
            left_ctrl = self.left_controls[i]
            right_ctrl = self.right_controls[i] if i < len(self.right_controls) else self.get_other_side(left_ctrl, True)
            
            if left_ctrl and right_ctrl:
                inversion_needed = self.detect_x_inversion_needed(left_ctrl, right_ctrl, verbose)
                results[f"{left_ctrl}<->{right_ctrl}"] = inversion_needed
        
        # Summary
        invert_count = sum(1 for need_invert in results.values() if need_invert)
        no_invert_count = len(results) - invert_count
        
        print(f"Analysis complete: {invert_count} pairs need inversion, {no_invert_count} pairs don't")
        
        if verbose:
            for pair, needs_invert in results.items():
                print(f"  {pair}: {'INVERT' if needs_invert else 'NO INVERSION'}")
        
        return results

    # =========================================================================
    # SECTION 9: UI CALLBACKS & HELPERS
    # =========================================================================



    # =========================================================================
    # SECTION 2: CONTROL MANAGEMENT (continued)
    # =========================================================================

    def load_biped_defaults(self, *_):
        lefts = ["L_leg_CTL", "L_arm_CTL", "L_foot_CTL", "L_hand_CTL", "L_clavicle_CTL"]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    def load_quad_defaults(self, *_):
        lefts = [
            "L_ikFrontLegHandle_CTL", "L_frontClavicle_CTL", "L_frontFootToe_CTL", "L_frontFootReverseRollBall_CTL",
            "L_frontFootIndex01_CTL", "L_frontFootIndex02_CTL", "L_frontFootMiddle01_CTL", "L_frontFootMiddle02_CTL",
            "L_frontFootRing01_CTL", "L_frontFootRing02_CTL", "L_frontFootPinky01_CTL", "L_frontFootPinky02_CTL"
        ]
        self.left_controls = lefts
        self.right_controls = [self.get_other_side(l, left_to_right=True) for l in lefts]
        cmds.textScrollList(self.left_list_field, edit=True, removeAll=True)
        cmds.textScrollList(self.right_list_field, edit=True, removeAll=True)
        for l, r in zip(self.left_controls, self.right_controls):
            cmds.textScrollList(self.left_list_field, edit=True, append=l)
            cmds.textScrollList(self.right_list_field, edit=True, append=r)

    # ---------------------
    # Actions: Spine inversion pass
    # ---------------------

    def invert_spine_channels(self, *_):
        """
        Enforce half-cycle antiphase or standard cycle on spine/centerline channels over the playback range.
        - rotateY, rotateZ, translateX, translateZ: antiphase (second half = negative of first half)
        - rotateX, translateY: standard cycle (second half = copy of first half)
        """
        sel = cmds.ls(selection=True) or []
        if not sel:
            cmds.warning("Select one or more controls to invert spine channels.")
            return
        spine_controls = self._get_spine_controls()
        if not spine_controls:
            cmds.warning("No spine controls defined. Add controls to the Spine Controls list first.")
            return
            
        try:
            invert_y = cmds.checkBox(self.invert_y_chk, query=True, value=True)
            invert_z = cmds.checkBox(self.invert_z_chk, query=True, value=True)
        except Exception:
            invert_y = self.spine_invert_y_default
            invert_z = self.spine_invert_z_default

        start, end, mid = self._playback_cycle_range()
        if end <= start:
            cmds.warning("Invalid playback range. Set a valid range (e.g., 0 to 40).")
            return

        # Define which channels get which type of cycling
        antiphase_attrs = []
        if invert_y:
            antiphase_attrs.append("rotateY")
        if invert_z:
            antiphase_attrs.append("rotateZ")
        antiphase_attrs += ["translateX"]
        standard_attrs = ["rotateX", "translateY", "translateZ"]

        count = 0
        for node in sel:
            if node not in spine_controls:
                continue
            # Antiphase channels
            for attr in antiphase_attrs:
                plug = f"{node}.{attr}"
                try:
                    if not cmds.objExists(plug):
                        continue
                except Exception:
                    continue
                if not self._anim_curve_for_attr(plug):
                    continue
                self._rebuild_second_half_antiphase(plug, start, mid, end)
                count += 1
            # Standard cycle channels
            for attr in standard_attrs:
                plug = f"{node}.{attr}"
                try:
                    if not cmds.objExists(plug):
                        continue
                except Exception:
                    continue
                if not self._anim_curve_for_attr(plug):
                    continue
                self._rebuild_second_half_standard(plug, start, mid, end)
                count += 1

        if count == 0:
            cmds.warning("No matching spine channels processed. Check selection, spine controls list, and playback range.")
        else:
            cmds.inViewMessage(amg=f"Applied cycle/antiphase to {count} channel(s) over [{start:.0f},{end:.0f}]", pos='midCenter', fade=True)

    def _rebuild_second_half_standard(self, plug, start, mid, end):
        """
        Make [mid,end] a standard cycle (copy of [start,mid]) for the given plug.
        """
        # Anchor values
        try:
            v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = None
        if not self._has_key_at(plug, start):
            self._ensure_key(plug, start, v_start)
        if not self._has_key_at(plug, mid):
            self._ensure_key(plug, mid, v_start if v_start is not None else None)

        # Unlock if needed
        relock = False
        try:
            if cmds.getAttr(plug, lock=True):
                relock = True
                cmds.setAttr(plug, lock=False)
        except Exception:
            pass

        # Clear second half
        try:
            cmds.cutKey(plug, time=(mid, end))
        except Exception:
            pass

        # Copy first half [start, mid) and paste to [mid, end)
        try:
            cmds.copyKey(plug, time=(start, mid), includeUpperBound=False)
        except Exception as e:
            cmds.warning(f"copyKey failed on {plug} [{start},{mid}): {e}")
            return
        try:
            cmds.pasteKey(plug, option='merge', timeOffset=(mid - start))
        except Exception as e:
            try:
                cmds.pasteKey(plug, option='merge')
            except Exception as e2:
                cmds.warning(f"pasteKey failed on {plug}: {e2}")
                return

        # Enforce anchors: end==start, mid==start
        try:
            if v_start is None:
                v_start = cmds.getAttr(plug, time=start)
        except Exception:
            v_start = 0.0
        self._ensure_key(plug, mid, float(v_start))
        self._ensure_key(plug, end, float(v_start))

        # Relock
        if relock:
            try:
                cmds.setAttr(plug, lock=True)
            except Exception:
                pass


    # =========================================================================
    # SECTION 10: COPY WITH OFFSET FUNCTIONALITY
    # =========================================================================
    
    def select_all_channels(self, *_):
        """Select all translation and rotation channels."""
        cmds.checkBox(self.translate_x_chk, edit=True, value=True)
        cmds.checkBox(self.translate_y_chk, edit=True, value=True)
        cmds.checkBox(self.translate_z_chk, edit=True, value=True)
        cmds.checkBox(self.rotate_x_chk, edit=True, value=True)
        cmds.checkBox(self.rotate_y_chk, edit=True, value=True)
        cmds.checkBox(self.rotate_z_chk, edit=True, value=True)
    
    def deselect_all_channels(self, *_):
        """Deselect all translation and rotation channels."""
        cmds.checkBox(self.translate_x_chk, edit=True, value=False)
        cmds.checkBox(self.translate_y_chk, edit=True, value=False)
        cmds.checkBox(self.translate_z_chk, edit=True, value=False)
        cmds.checkBox(self.rotate_x_chk, edit=True, value=False)
        cmds.checkBox(self.rotate_y_chk, edit=True, value=False)
        cmds.checkBox(self.rotate_z_chk, edit=True, value=False)
    
    def get_selected_channels(self):
        """Get list of selected channels for copy operation."""
        channels = []
        if cmds.checkBox(self.translate_x_chk, query=True, value=True):
            channels.append('translateX')
        if cmds.checkBox(self.translate_y_chk, query=True, value=True):
            channels.append('translateY')
        if cmds.checkBox(self.translate_z_chk, query=True, value=True):
            channels.append('translateZ')
        if cmds.checkBox(self.rotate_x_chk, query=True, value=True):
            channels.append('rotateX')
        if cmds.checkBox(self.rotate_y_chk, query=True, value=True):
            channels.append('rotateY')
        if cmds.checkBox(self.rotate_z_chk, query=True, value=True):
            channels.append('rotateZ')
        return channels
    
    def copy_with_offset(self, *_):
        """Copy animation from first selected control to subsequent controls with offset."""
        sel = cmds.ls(selection=True)
        if len(sel) < 2:
            cmds.warning("Select source control first, then one or more target controls.")
            return
        
        source_ctrl = sel[0]
        target_ctrls = sel[1:]
        
        # Get offset values
        time_offset = cmds.intField(self.time_offset_copy_field, query=True, value=True)
        value_offset = cmds.floatField(self.value_offset_copy_field, query=True, value=True)
        
        # Get selected channels
        channels = self.get_selected_channels()
        if not channels:
            cmds.warning("No channels selected. Please select at least one translation or rotation channel.")
            return
        
        # Copy to each target with cumulative offset
        for i, target_ctrl in enumerate(target_ctrls):
            cumulative_time_offset = time_offset * (i + 1)
            cumulative_value_offset = value_offset * (i + 1)
            
            self.copy_animation_with_offset(source_ctrl, target_ctrl, channels, 
                                          cumulative_time_offset, cumulative_value_offset)
        
        cmds.inViewMessage(amg=f"Copied animation from {source_ctrl} to {len(target_ctrls)} targets with offset", 
                          pos='midCenter', fade=True)
    
    def copy_animation_with_offset(self, source_ctrl, target_ctrl, channels, time_offset, value_offset):
        """Copy animation from source to target with specified offsets."""
        if not (cmds.objExists(source_ctrl) and cmds.objExists(target_ctrl)):
            cmds.warning(f"Controls not found: {source_ctrl} or {target_ctrl}")
            return
        
        for channel in channels:
            source_attr = f"{source_ctrl}.{channel}"
            target_attr = f"{target_ctrl}.{channel}"
            
            # Skip if source doesn't have this attribute or it's not animated
            if not cmds.objExists(source_attr):
                continue
            
            source_curve = self._anim_curve_for_attr(source_attr)
            if not source_curve:
                continue
            
            # Skip if target doesn't have this attribute
            if not cmds.objExists(target_attr):
                continue
            
            # Get time range from source
            try:
                time_range = cmds.keyframe(source_curve, query=True, timeChange=True)
                if not time_range:
                    continue
                    
                start_t = min(time_range)
                end_t = max(time_range)
                
                # Copy keys from source
                cmds.copyKey(source_attr, time=(start_t, end_t), includeUpperBound=True)
                
                # Handle locked attributes
                relock = False
                try:
                    if cmds.getAttr(target_attr, lock=True):
                        relock = True
                        cmds.setAttr(target_attr, lock=False)
                except Exception:
                    pass
                
                # Paste with offsets
                try:
                    cmds.pasteKey(target_attr, option='replaceCompletely', 
                                timeOffset=time_offset, valueOffset=value_offset)
                except Exception as e:
                    # Fallback paste
                    try:
                        cmds.pasteKey(target_attr, option='replaceCompletely')
                        # Apply offsets manually if paste with offsets failed
                        if time_offset != 0:
                            cmds.keyframe(target_attr, edit=True, relative=True, timeChange=time_offset)
                        if value_offset != 0:
                            cmds.keyframe(target_attr, edit=True, relative=True, valueChange=value_offset)
                    except Exception as e2:
                        cmds.warning(f"Failed to paste keys to {target_attr}: {e2}")
                
                # Restore lock state
                if relock:
                    try:
                        cmds.setAttr(target_attr, lock=True)
                    except Exception:
                        pass
                        
            except Exception as e:
                cmds.warning(f"Error copying {source_attr} to {target_attr}: {e}")

    # =========================================================================
    # SECTION 11: TANGENT SMOOTHING FOR CYCLE CONTINUITY
    # =========================================================================
    
    def _ensure_smooth_cycle_tangents(self, curves, start_time, end_time):
        """Ensure smooth tangent continuity at cycle boundaries for seamless looping."""
        if not curves:
            return
            
        # Normalize to list
        if isinstance(curves, str):
            curves = [curves]
            
        for curve in curves:
            if not curve or not cmds.objExists(curve):
                continue
                
            self._apply_smooth_cycle_tangents_to_curve(curve, start_time, end_time)
    
    def _apply_smooth_cycle_tangents_to_curve(self, curve, start_time, end_time):
        """Apply smooth cycle tangents to a single curve."""
        try:
            # Get all keyframe times on this curve
            key_times = cmds.keyframe(curve, query=True, timeChange=True) or []
            if len(key_times) < 2:
                return
                
            # Find start and end keys (closest to start_time and end_time)
            start_key = min(key_times, key=lambda t: abs(t - start_time))
            end_key = min(key_times, key=lambda t: abs(t - end_time))
            
            if start_key == end_key:
                return
            
            # Ensure values match for perfect cycling
            start_value = cmds.keyframe(curve, time=(start_key, start_key), query=True, valueChange=True)[0]
            end_value = cmds.keyframe(curve, time=(end_key, end_key), query=True, valueChange=True)[0]
            
            if abs(start_value - end_value) > 0.001:  # Small tolerance for floating point
                cmds.keyframe(curve, time=(end_key, end_key), valueChange=start_value)
                print(f"DEBUG: Matched end value to start value for {curve}")
            
            # Apply directional tangent smoothing for natural curve flow + cycle continuity
            self._apply_directional_cycle_tangents(curve, key_times, start_key, end_key)
                
        except Exception as e:
            print(f"DEBUG: Error applying smooth cycle tangents to {curve}: {e}")
    
    def _apply_directional_cycle_tangents(self, curve, key_times, start_key, end_key):
        """Apply tangents that maintain natural curve flow AND cycle continuity."""
        try:
            # Find next key after start and previous key before end for natural flow
            start_idx = key_times.index(start_key)
            end_idx = key_times.index(end_key)
            
            # Get the next key after start (for natural out-tangent direction)
            next_key = key_times[start_idx + 1] if start_idx + 1 < len(key_times) else None
            # Get the previous key before end (for natural in-tangent direction)  
            prev_key = key_times[end_idx - 1] if end_idx - 1 >= 0 else None
            
            print(f"DEBUG: Curve {curve} - start:{start_key}, end:{end_key}, next:{next_key}, prev:{prev_key}")
            
            # STEP 1: Set natural flow tangents (curve should flow smoothly through keys)
            if next_key is not None:
                # First key out-tangent should point toward next key (natural flow)
                self._set_tangent_toward_key(curve, start_key, next_key, 'out')
                
            if prev_key is not None:
                # Last key in-tangent should point toward previous key (natural flow)
                self._set_tangent_toward_key(curve, end_key, prev_key, 'in')
            
            # STEP 2: Set cycle continuity tangents
            # Get the tangent angles we just set for natural flow
            start_out_angle = cmds.keyTangent(curve, time=(start_key, start_key), query=True, outAngle=True)[0]
            end_out_angle = cmds.keyTangent(curve, time=(end_key, end_key), query=True, outAngle=True)[0]
            
            # First key in-tangent should match last key out-tangent (for pre-infinity cycling)
            cmds.keyTangent(curve, time=(start_key, start_key), 
                          inAngle=end_out_angle, inTangentType='fixed')
            
            # Last key in-tangent should match first key out-tangent (for post-infinity cycling)  
            cmds.keyTangent(curve, time=(end_key, end_key), 
                          inAngle=start_out_angle, inTangentType='fixed')
            
            print(f"DEBUG: Applied directional cycle tangents - start_out:{start_out_angle}, end_out:{end_out_angle}")
            
        except Exception as e:
            print(f"DEBUG: Error in directional cycle tangents: {e}")
    
    def _set_tangent_toward_key(self, curve, from_key, to_key, tangent_type):
        """Set a tangent to point toward another key for natural curve flow."""
        try:
            # Get key values and times
            from_value = cmds.keyframe(curve, time=(from_key, from_key), query=True, valueChange=True)[0]
            to_value = cmds.keyframe(curve, time=(to_key, to_key), query=True, valueChange=True)[0]
            
            # Calculate angle from from_key toward to_key
            time_diff = to_key - from_key
            value_diff = to_value - from_value
            
            if abs(time_diff) > 0.001:  # Avoid division by zero
                # Calculate angle in degrees (Maya uses degrees for tangent angles)
                import math
                angle_radians = math.atan2(value_diff, time_diff)
                angle_degrees = math.degrees(angle_radians)
                
                # Apply the tangent
                if tangent_type == 'out':
                    cmds.keyTangent(curve, time=(from_key, from_key), 
                                  outAngle=angle_degrees, outTangentType='fixed')
                elif tangent_type == 'in':  
                    cmds.keyTangent(curve, time=(from_key, from_key), 
                                  inAngle=angle_degrees, inTangentType='fixed')
                
                print(f"DEBUG: Set {tangent_type} tangent at {from_key} toward {to_key}: {angle_degrees:.2f}°")
                
        except Exception as e:
            print(f"DEBUG: Error setting tangent toward key: {e}")


def launch_cycle_maker():
    """Launch the Cycle Maker UI tool."""
    CycleMakerUI()

if __name__ == "__main__":
    launch_cycle_maker()